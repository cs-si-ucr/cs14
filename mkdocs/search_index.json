{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs14-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS14 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lab_week_01/", 
            "text": "Lab 1: Templates\n\n\nYou may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node. \n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode * next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};\n\n\n\n\nThat's all fine and dandy, but if instead want a \nDoubleList\n or a\n\nStringList\n, then we are in trouble. \n\n\nA common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to \nmake mistakes\n\ncopy and pasting.\n\n\nIntroducing templates!\n\n\nThe solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.\n\n\nIn fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.\n\n\nTo create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".\n\n\nvector\nint\n numbers; // creates a vector of integers\nvector\nstring\n words; // creates a vector of strings\n\n\n\n\nTo create a new class template, before our class declaration we use the keyword \ntemplate\n followed by a type parameter inside \"angle-brackets\"\ne.g. \ntemplate\ntypename T\n. The keyword \ntypename\n tells the compiler\nthat \nT\n is a placeholder for an actual type. \n\n\nNote: \nT\n is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is \nContainer\n\n\nLet's say, we want to create a templated version of our Node and List.\n\n\nIntNode\n becomes:\n\n\ntemplate\ntypename T\n\nstruct Node {\n   T val;\n   Node\nT\n * next;\n};\n\n\n\n\nand \nIntLinkedList\n becomes:\n\n\ntemplate\ntypename T\n\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node\nT\n * head;\n};\n\n\n\n\nTo create a \nLinkedList\n of doubles, we declare the list as so:\n\n\nLinkedList\ndouble\n list;\n\n\n\n\nIn order to template functions and method, we do something similar.\n\n\nFor example, if we want to define the templated LinkedList's\n\npush_front\n method:\n\n\ntemplate\ntypename T\n\nLinkedList\nT\n::push_front(T val) {\n    Node * new_node = new Node\nT\n();\n    new_node -\n val = val;\n\n    Node * old_head = this -\n head;\n    new_node -\n next = old_head;\n    this -\n head = new_node;\n}\n\n\n\n\nFor more info on templates check out \nthis FAQ\n!\n\n\nExercises\n\n\nImplement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier! \n\n\nPro-Tip: before implementing the class as a class template, \ntypedef\n the type \nT\n as an integer and replace type with \nT\n as needed.\n\ne.g.\n\n\ntypedef int T; // give the int an alias which is T\nT my_int = 42;\n\n\n\n\nThis give you much nicer error messages and makes it easier to debug.\n\n\nExample Usage, should implement at least the following methods:\n\n\nMyVector\nstring\n vec;\nvec.push_back(\nCS14\n);\nvec.push_back(\nWorld\n);\nvec.insert(\nHello\n, 0); \ncout \n vec.front() \n endl; // \nHello\n\ncout \n vec.back() \n endl; // \nWorld\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nCS14\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nHello\n\n\nMyVector\nint\n another_vec;\nanother_vec.push_back(42);\n\n\n\n\nStretch-goal exercise:\n\n\nRewrite your IntList as a class template!", 
            "title": "Lab Week 1"
        }, 
        {
            "location": "/lab_week_01/#lab-1-templates", 
            "text": "You may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".  In order to implement a Linked List, you must define the structure\nfor an individual node.   For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode * next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};  That's all fine and dandy, but if instead want a  DoubleList  or a StringList , then we are in trouble.   A common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to  make mistakes \ncopy and pasting.", 
            "title": "Lab 1: Templates"
        }, 
        {
            "location": "/lab_week_01/#introducing-templates", 
            "text": "The solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.  In fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.  To create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".  vector int  numbers; // creates a vector of integers\nvector string  words; // creates a vector of strings  To create a new class template, before our class declaration we use the keyword  template  followed by a type parameter inside \"angle-brackets\"\ne.g.  template typename T . The keyword  typename  tells the compiler\nthat  T  is a placeholder for an actual type.   Note:  T  is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is  Container  Let's say, we want to create a templated version of our Node and List.  IntNode  becomes:  template typename T \nstruct Node {\n   T val;\n   Node T  * next;\n};  and  IntLinkedList  becomes:  template typename T \nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node T  * head;\n};  To create a  LinkedList  of doubles, we declare the list as so:  LinkedList double  list;  In order to template functions and method, we do something similar.  For example, if we want to define the templated LinkedList's push_front  method:  template typename T \nLinkedList T ::push_front(T val) {\n    Node * new_node = new Node T ();\n    new_node -  val = val;\n\n    Node * old_head = this -  head;\n    new_node -  next = old_head;\n    this -  head = new_node;\n}  For more info on templates check out  this FAQ !", 
            "title": "Introducing templates!"
        }, 
        {
            "location": "/lab_week_01/#exercises", 
            "text": "Implement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!   Pro-Tip: before implementing the class as a class template,  typedef  the type  T  as an integer and replace type with  T  as needed. \ne.g.  typedef int T; // give the int an alias which is T\nT my_int = 42;  This give you much nicer error messages and makes it easier to debug.  Example Usage, should implement at least the following methods:  MyVector string  vec;\nvec.push_back( CS14 );\nvec.push_back( World );\nvec.insert( Hello , 0); \ncout   vec.front()   endl; //  Hello \ncout   vec.back()   endl; //  World \nvec.pop_back();\ncout   vec.back()   endl; //  CS14 \nvec.pop_back();\ncout   vec.back()   endl; //  Hello \n\nMyVector int  another_vec;\nanother_vec.push_back(42);", 
            "title": "Exercises"
        }, 
        {
            "location": "/lab_week_01/#stretch-goal-exercise", 
            "text": "Rewrite your IntList as a class template!", 
            "title": "Stretch-goal exercise:"
        }, 
        {
            "location": "/lab_week_02/", 
            "text": "Lab 2: The Standard Template Library\n\n\nLike templates, you've already been using a small portion of the Standard Template Library.\n\n\nNamely, you're already well-acquainted with the contiguous container \nstd::vector\n and maybe even \nstd::list\n.\n\n\nThe Standard Template Library, or the \nSTL\n for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.\n\n\nSome of these algorithms range from simple algorithms such\nas \nstd::swap\n to the more complex \nstd::sort\n.\n\n\nThe motivation for learning and mastering the STL is to write \ncode that is clear and concise\n.\n\n\nIterators\n\n\nProbably the most important and inescapable concept in the\nSTL is the types we call iterators.\n\n\nIterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).\n\n\nThe easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).\n\n\n\"Enough talk, show me the code!\"\n Here's how you can iterate through a vector using iterators!\n\n\nvector\nint\n vec {1, 2, 3};\nvector\nint\n::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout \n *vec_iterator \n ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \n1 2 3 \n\n\n\n\n\nNote the \nvec.begin()\n and \nvec.end()\n calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type \nvector\nint\n::iterator\n.\n\n\nvec.begin()\n returns an iterator to beginning of \nvec\n. However, \nvec.end()\n returns an iterator to the element \none past\n the last element.\n\n\nThis is pictured below (image from en.cppreference.com)\n\n\n\nA lot of algorithms in the STL, including \nstd::sort\n\nexpect iterators as arguments. \n(and usually specific types of iterators)\n\n\nOne of the function prototypes for \nstd::sort\n looks\nsomething like this:\n\n\ntemplate\ntypename RandomIt\n\nvoid sort(Iterator first, Iterator last);\n\n\n\n\nAs long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).\n\n\n#include \niostream\n\n#include \nvector\n\n#include \nalgorithm\n\nusing namespace std;\nint main() {\n    vector\nint\n vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout \n *vec_iter \n ' ';\n    }\n}\n\n\n\n\n`\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nThat's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!\n\n\nFunction Objects\n\n\nBack in CS12, you learned that you can \noverload\n\nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the\n\n+\n operator may look like this (assume the \ngcd\n function is defined):\n\n\nbool operator+(const Rational \n other) {\n    int new_denom = gcd(this -\n denom, other.denom);\n    int this_multipler = new_denom/(this -\n denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -\n numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}\n\n\n\n\nYou can also overload the function call operator by\ndefining a function with the function name \noperator()\n.\n\n\ne.g.\n\n\n#include \niostream\n\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout \n count.get_count() \n endl;\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nOverloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include \nstd::sort\n\nand \nstd::copy_if\n. The most common types of\nfunction objects that these algorithms accept as input are\n\ncomparison function objects\n which return\ntrue if the first argument is \nconsidered\n less than the second and\na unary predicate which returns true if it satisfies some condition.\n\n\n#include \niostream\n\n#include \nalgorithm\n\n#include \nvector\n\n#include \nlist\n\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int \n a, const int \n b ) const {\n            return a \n b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int \n x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector\nint\n from_vector {1, 2, 3, 4};\n    list\nint\n to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout \n elem \n ' ';\n    }\n    cout \n endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout \n elem \n ' ';\n    }\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nExercise 1\n\n\nImplement your own STL-like reverse function, the reverse function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid my_reverse(BidirectionalIter first, BidirectionalIter last)\n\n\n\n\nThe function should reverse a portion of a container given two Bidirectional iterators (iterators you can move forward and backward).\nThe elements within the range [first, last) are reversed.\n\n\nExercise 2\n\n\nImplement rotate as an STL-like function. The rotate function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid my_rotate(BidirectionalIter first, BidirectionalIter n_first,\n               BidirectionalIter last)\n\n\n\n\nThe function should rotate the container given three Bidirectional\niterators: first, n_first and last. The rotate should make n_first\nthe first element in the container and n_first-1 the last element\nin the container. The new order should be [n_first, ..., last,  first, ... n_first-1]\n\n\nSuper Hint: The reverse function you just implement should really\ncome in handy!\n\n\nStretch-goal Exercise\n\n\nImplement mergesort as an STL-like function. The mergesort function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid mergesort(BidirectionalIter first, BidirectionalIter last)\n\n\n\n\nGiven two Bidirectional Iterators, sort the container's elements\nwithin the range [first, last).\n\n\nUltra-hint: \nstd::inplace_merge\n and \nstd::distance\n are lifesavers here!\n\n\nCool References\n\n\nStandard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Lab Week 2"
        }, 
        {
            "location": "/lab_week_02/#lab-2-the-standard-template-library", 
            "text": "Like templates, you've already been using a small portion of the Standard Template Library.  Namely, you're already well-acquainted with the contiguous container  std::vector  and maybe even  std::list .  The Standard Template Library, or the  STL  for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.  Some of these algorithms range from simple algorithms such\nas  std::swap  to the more complex  std::sort .  The motivation for learning and mastering the STL is to write  code that is clear and concise .", 
            "title": "Lab 2: The Standard Template Library"
        }, 
        {
            "location": "/lab_week_02/#iterators", 
            "text": "Probably the most important and inescapable concept in the\nSTL is the types we call iterators.  Iterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).  The easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).  \"Enough talk, show me the code!\"  Here's how you can iterate through a vector using iterators!  vector int  vec {1, 2, 3};\nvector int ::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout   *vec_iterator   ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs  1 2 3    Note the  vec.begin()  and  vec.end()  calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type  vector int ::iterator .  vec.begin()  returns an iterator to beginning of  vec . However,  vec.end()  returns an iterator to the element  one past  the last element.  This is pictured below (image from en.cppreference.com)  A lot of algorithms in the STL, including  std::sort \nexpect iterators as arguments.  (and usually specific types of iterators)  One of the function prototypes for  std::sort  looks\nsomething like this:  template typename RandomIt \nvoid sort(Iterator first, Iterator last);  As long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).  #include  iostream \n#include  vector \n#include  algorithm \nusing namespace std;\nint main() {\n    vector int  vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout   *vec_iter   ' ';\n    }\n}  ` Try it yourself - before compiling guess what the above program outputs.  That's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!", 
            "title": "Iterators"
        }, 
        {
            "location": "/lab_week_02/#function-objects", 
            "text": "Back in CS12, you learned that you can  overload \nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the +  operator may look like this (assume the  gcd  function is defined):  bool operator+(const Rational   other) {\n    int new_denom = gcd(this -  denom, other.denom);\n    int this_multipler = new_denom/(this -  denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -  numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}  You can also overload the function call operator by\ndefining a function with the function name  operator() .  e.g.  #include  iostream \nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout   count.get_count()   endl;\n}  Try it yourself - before compiling guess what the above program outputs.  Overloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include  std::sort \nand  std::copy_if . The most common types of\nfunction objects that these algorithms accept as input are comparison function objects  which return\ntrue if the first argument is  considered  less than the second and\na unary predicate which returns true if it satisfies some condition.  #include  iostream \n#include  algorithm \n#include  vector \n#include  list \nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int   a, const int   b ) const {\n            return a   b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int   x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector int  from_vector {1, 2, 3, 4};\n    list int  to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout   elem   ' ';\n    }\n    cout   endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout   elem   ' ';\n    }\n}  Try it yourself - before compiling guess what the above program outputs.", 
            "title": "Function Objects"
        }, 
        {
            "location": "/lab_week_02/#exercise-1", 
            "text": "Implement your own STL-like reverse function, the reverse function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid my_reverse(BidirectionalIter first, BidirectionalIter last)  The function should reverse a portion of a container given two Bidirectional iterators (iterators you can move forward and backward).\nThe elements within the range [first, last) are reversed.", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_02/#exercise-2", 
            "text": "Implement rotate as an STL-like function. The rotate function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid my_rotate(BidirectionalIter first, BidirectionalIter n_first,\n               BidirectionalIter last)  The function should rotate the container given three Bidirectional\niterators: first, n_first and last. The rotate should make n_first\nthe first element in the container and n_first-1 the last element\nin the container. The new order should be [n_first, ..., last,  first, ... n_first-1]  Super Hint: The reverse function you just implement should really\ncome in handy!", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_02/#stretch-goal-exercise", 
            "text": "Implement mergesort as an STL-like function. The mergesort function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid mergesort(BidirectionalIter first, BidirectionalIter last)  Given two Bidirectional Iterators, sort the container's elements\nwithin the range [first, last).  Ultra-hint:  std::inplace_merge  and  std::distance  are lifesavers here!", 
            "title": "Stretch-goal Exercise"
        }, 
        {
            "location": "/lab_week_02/#cool-references", 
            "text": "Standard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Cool References"
        }
    ]
}