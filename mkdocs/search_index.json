{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs14-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS14 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lec_week_02/", 
            "text": "Lecture 2: Lists\n\n\nQuestion of the day!\n\n\n\n\nHow many programmers does it take to change a light bulb?\n\n\n\n\n\n\n\n\nNone. That's a hardware problem.\n\n\n\n\n\n\n\n\n\n\nLists\n\n\nAn \nabstract data type (ADT)\n is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.\n\n\nLists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a \nnode\n.\n\n\nSingly-linked Lists\n\n\nSingly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the \nhead\n, and the last node is the \ntail\n.\n\n\n\n    The head in this case would be the node with value 12 and the tail would be the node with value 37\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node.\n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};\n\n\n\n\nDoubly Linked List\n\n\nIn a doubly linked list, each node contains three parts:\n\n\n\n\nData\n\n\nPointer to the next node\n\n\nPointer to the previous node\n\n\n\n\n\n\nIn this case, our new struct may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};\n\n\n\n\nExercise 1: Fibonacci Exercise\n\n\nFn = Fn-1 + Fn-2\n\n\nF0 = 0, F1 = 1\n\n\nWrite a program that will calculate a specified fibonacci number using the \nstd::list data\n\nstructure. Think about how to use a list to store values of the formula above.\n\n\n\n\nInput:    integer n\n\n\nOutput:   nth Fibonacci number\n\n\n\n\nExample:\n\n\n\n\nWhich Fibonacci number to calculate: \n10\n\n\n10th Fibonacci number: \n55\n\n\n\n\nExercise 2: Palindrome Exercise\n\n\nWrite a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.\n\n\n\n\nInput:    string input\n\n\nOutput:   result of the palindrome test\n\n\n\n\nExample:\n\n\n\n\nEnter a word to test for palindrome: \ntacocats\n\n\ntacocats\n is not a palindrome.\n\n\n\n\nKey functions to incorporate: back(), pop_back()\n\n\nExercise 3: Animation!\n\n\nWe've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!\n\n\nAt the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into \ncout\n!\n\n\nNote, since we're giving you a precompiled file, you're going to have to use C9 for this exercise\n\n\nHow to get the code\n\n\nIn your C9 terminal, run the following in the directory where you want the code\n\n\ngit clone https://github.com/scohe001/Animations\n\n\n\nYou'll notice you now have a \nmain\n, an \nAnimator\n class and a couple animation files (don't look at them yet, it'll ruin the surprise!\n*\n).\n\n\nWe've already completely implemented the \nAnimator\n class for you and compiled it, so all you'll have to do is finish off the \nmain\n skeleton! The details for doing so are in the comments, so don't just delete them!\n\n\nCompiling\n\n\nSince we're using C++11 features and threading, you'll have to compile with the following:\n\n\ng++ -std=c++11 -pthread -Wall main.cpp animation.o\n\n\n\nAfter you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!\n\n\nOnce you have all of the animations working, delete \nanimation.o\n and use the skeleton \nanimation.cpp\n we've given you to complete the \nAnimation\n class! Recompiling the \nAnimation\n class should look like the following:\n\n\ng++ -std=c++11 -pthread -c animation.cpp\n\n\n\n*\n Since you're all CS majors I'm sure the lot of you have already looked at them \n.", 
            "title": "Lecture Week 2"
        }, 
        {
            "location": "/lec_week_02/#lecture-2-lists", 
            "text": "", 
            "title": "Lecture 2: Lists"
        }, 
        {
            "location": "/lec_week_02/#question-of-the-day", 
            "text": "How many programmers does it take to change a light bulb?     None. That's a hardware problem.", 
            "title": "Question of the day!"
        }, 
        {
            "location": "/lec_week_02/#lists", 
            "text": "An  abstract data type (ADT)  is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.  Lists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a  node .", 
            "title": "Lists"
        }, 
        {
            "location": "/lec_week_02/#singly-linked-lists", 
            "text": "Singly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the  head , and the last node is the  tail .  \n    The head in this case would be the node with value 12 and the tail would be the node with value 37  In order to implement a Linked List, you must define the structure\nfor an individual node.  For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};", 
            "title": "Singly-linked Lists"
        }, 
        {
            "location": "/lec_week_02/#doubly-linked-list", 
            "text": "In a doubly linked list, each node contains three parts:   Data  Pointer to the next node  Pointer to the previous node    In this case, our new struct may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};", 
            "title": "Doubly Linked List"
        }, 
        {
            "location": "/lec_week_02/#exercise-1-fibonacci-exercise", 
            "text": "Fn = Fn-1 + Fn-2  F0 = 0, F1 = 1  Write a program that will calculate a specified fibonacci number using the  std::list data \nstructure. Think about how to use a list to store values of the formula above.   Input:    integer n  Output:   nth Fibonacci number   Example:   Which Fibonacci number to calculate:  10  10th Fibonacci number:  55", 
            "title": "Exercise 1: Fibonacci Exercise"
        }, 
        {
            "location": "/lec_week_02/#exercise-2-palindrome-exercise", 
            "text": "Write a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.   Input:    string input  Output:   result of the palindrome test   Example:   Enter a word to test for palindrome:  tacocats  tacocats  is not a palindrome.   Key functions to incorporate: back(), pop_back()", 
            "title": "Exercise 2: Palindrome Exercise"
        }, 
        {
            "location": "/lec_week_02/#exercise-3-animation", 
            "text": "We've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!  At the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into  cout !  Note, since we're giving you a precompiled file, you're going to have to use C9 for this exercise", 
            "title": "Exercise 3: Animation!"
        }, 
        {
            "location": "/lec_week_02/#how-to-get-the-code", 
            "text": "In your C9 terminal, run the following in the directory where you want the code  git clone https://github.com/scohe001/Animations  You'll notice you now have a  main , an  Animator  class and a couple animation files (don't look at them yet, it'll ruin the surprise! * ).  We've already completely implemented the  Animator  class for you and compiled it, so all you'll have to do is finish off the  main  skeleton! The details for doing so are in the comments, so don't just delete them!", 
            "title": "How to get the code"
        }, 
        {
            "location": "/lec_week_02/#compiling", 
            "text": "Since we're using C++11 features and threading, you'll have to compile with the following:  g++ -std=c++11 -pthread -Wall main.cpp animation.o  After you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!  Once you have all of the animations working, delete  animation.o  and use the skeleton  animation.cpp  we've given you to complete the  Animation  class! Recompiling the  Animation  class should look like the following:  g++ -std=c++11 -pthread -c animation.cpp  *  Since you're all CS majors I'm sure the lot of you have already looked at them  .", 
            "title": "Compiling"
        }, 
        {
            "location": "/lab_week_02/", 
            "text": "Lab 2: The Standard Template Library\n\n\nThe Standard Template Library, or the \nSTL\n for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.\n\n\nSome of these algorithms range from simple algorithms such\nas \nstd::swap\n to the more complex \nstd::sort\n.\n\n\nThe motivation for learning and mastering the STL is to write \ncode that is clear and concise\n.\n\n\nIterators\n\n\nProbably the most important and inescapable concept in the\nSTL is the types we call iterators.\n\n\nIterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).\n\n\nThe easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).\n\n\n\"Enough talk, show me the code!\"\n Here's how you can iterate through a vector using iterators!\n\n\nvector\nint\n vec {1, 2, 3};\nvector\nint\n::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout \n *vec_iterator \n ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \n1 2 3 \n\n\n\n\n\nNote the \nvec.begin()\n and \nvec.end()\n calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type \nvector\nint\n::iterator\n.\n\n\nvec.begin()\n returns an iterator to beginning of \nvec\n. However, \nvec.end()\n returns an iterator to the element \none past\n the last element.\n\n\nThis is pictured below (image from en.cppreference.com)\n\n\n\nA lot of algorithms in the STL, including \nstd::sort\n\nexpect iterators as arguments. \n(and usually specific types of iterators)\n\n\nOne of the function prototypes for \nstd::sort\n looks\nsomething like this:\n\n\ntemplate\ntypename RandomIt\n\nvoid sort(Iterator first, Iterator last);\n\n\n\n\nAs long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).\n\n\n#include \niostream\n\n#include \nvector\n\n#include \nalgorithm\n\nusing namespace std;\nint main() {\n    vector\nint\n vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout \n *vec_iter \n ' ';\n    }\n}\n\n\n\n\n`\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nThat's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!\n\n\nFunction Objects\n\n\nBack in CS12, you learned that you can \noverload\n\nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the\n\n+\n operator may look like this (assume the \ngcd\n function is defined):\n\n\nbool operator+(const Rational \n other) {\n    int new_denom = gcd(this -\n denom, other.denom);\n    int this_multipler = new_denom/(this -\n denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -\n numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}\n\n\n\n\nYou can also overload the function call operator by\ndefining a function with the function name \noperator()\n.\n\n\ne.g.\n\n\n#include \niostream\n\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout \n count.get_count() \n endl;\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nOverloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include \nstd::sort\n\nand \nstd::copy_if\n. The most common types of\nfunction objects that these algorithms accept as input are\n\ncomparison function objects\n which return\ntrue if the first argument is \nconsidered\n less than the second and\na unary predicate which returns true if it satisfies some condition.\n\n\n#include \niostream\n\n#include \nalgorithm\n\n#include \nvector\n\n#include \nlist\n\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int \n a, const int \n b ) const {\n            return a \n b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int \n x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector\nint\n from_vector {1, 2, 3, 4};\n    list\nint\n to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout \n elem \n ' ';\n    }\n    cout \n endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout \n elem \n ' ';\n    }\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nExercise 1 - Reverse Polish Notation\n\n\nReverse Polish notation (RPN)\n is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.\n\n\nIn reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.\n\n\nAn advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".\n\n\nYour task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.\n\n\nExample:\n\n\n\n\nInput: 5 1 2 + 4 * + 3 -\n\n\nOutput: 14\n\n\n\n\nFor this exercise, implement the calculator using your choice of list.\n\n\nCool References\n\n\nStandard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Lab Week 2"
        }, 
        {
            "location": "/lab_week_02/#lab-2-the-standard-template-library", 
            "text": "The Standard Template Library, or the  STL  for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.  Some of these algorithms range from simple algorithms such\nas  std::swap  to the more complex  std::sort .  The motivation for learning and mastering the STL is to write  code that is clear and concise .", 
            "title": "Lab 2: The Standard Template Library"
        }, 
        {
            "location": "/lab_week_02/#iterators", 
            "text": "Probably the most important and inescapable concept in the\nSTL is the types we call iterators.  Iterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).  The easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).  \"Enough talk, show me the code!\"  Here's how you can iterate through a vector using iterators!  vector int  vec {1, 2, 3};\nvector int ::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout   *vec_iterator   ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs  1 2 3    Note the  vec.begin()  and  vec.end()  calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type  vector int ::iterator .  vec.begin()  returns an iterator to beginning of  vec . However,  vec.end()  returns an iterator to the element  one past  the last element.  This is pictured below (image from en.cppreference.com)  A lot of algorithms in the STL, including  std::sort \nexpect iterators as arguments.  (and usually specific types of iterators)  One of the function prototypes for  std::sort  looks\nsomething like this:  template typename RandomIt \nvoid sort(Iterator first, Iterator last);  As long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).  #include  iostream \n#include  vector \n#include  algorithm \nusing namespace std;\nint main() {\n    vector int  vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout   *vec_iter   ' ';\n    }\n}  ` Try it yourself - before compiling guess what the above program outputs.  That's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!", 
            "title": "Iterators"
        }, 
        {
            "location": "/lab_week_02/#function-objects", 
            "text": "Back in CS12, you learned that you can  overload \nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the +  operator may look like this (assume the  gcd  function is defined):  bool operator+(const Rational   other) {\n    int new_denom = gcd(this -  denom, other.denom);\n    int this_multipler = new_denom/(this -  denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -  numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}  You can also overload the function call operator by\ndefining a function with the function name  operator() .  e.g.  #include  iostream \nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout   count.get_count()   endl;\n}  Try it yourself - before compiling guess what the above program outputs.  Overloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include  std::sort \nand  std::copy_if . The most common types of\nfunction objects that these algorithms accept as input are comparison function objects  which return\ntrue if the first argument is  considered  less than the second and\na unary predicate which returns true if it satisfies some condition.  #include  iostream \n#include  algorithm \n#include  vector \n#include  list \nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int   a, const int   b ) const {\n            return a   b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int   x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector int  from_vector {1, 2, 3, 4};\n    list int  to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout   elem   ' ';\n    }\n    cout   endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout   elem   ' ';\n    }\n}  Try it yourself - before compiling guess what the above program outputs.", 
            "title": "Function Objects"
        }, 
        {
            "location": "/lab_week_02/#exercise-1-reverse-polish-notation", 
            "text": "Reverse Polish notation (RPN)  is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.  In reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.  An advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".  Your task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.  Example:   Input: 5 1 2 + 4 * + 3 -  Output: 14   For this exercise, implement the calculator using your choice of list.", 
            "title": "Exercise 1 - Reverse Polish Notation"
        }, 
        {
            "location": "/lab_week_02/#cool-references", 
            "text": "Standard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Cool References"
        }, 
        {
            "location": "/lec_week_03/", 
            "text": "Stacks and Queues\n\n\nStacks\n\n\nStacks are \nLIFO\n (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.\n\n\nHere's a small demo of how stacks work:\n\n\n#include \niostream\n\n#include \nstack\n\n\nusing namespace std;\n\nint main() {\n  stack\nint\n s;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout \n \nPopping (\n \n s.top() \n \n)\n \n endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout \n \nstack is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nTry running that and see what is output.\nGo ahead. I'll wait.\n\n\nWere you surprised by the output?\n\n\nHere are some commonly used stack ADT operations:\n\n\n\n\n\n\n\n\nMember function\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npush(element)\n;\n\n\nInsert element\n\n\n\n\n\n\npop(element)\n;\n\n\nRemove top element\n\n\n\n\n\n\ntop()\n;\n\n\nAccess the top of the stack\n\n\n\n\n\n\nsize()\n;\n\n\nReturns the size\n\n\n\n\n\n\nempty()\n;\n\n\nReturns true if the container's size is 0, false otherwise\n\n\n\n\n\n\n\n\nQuick Exercise: Remember how you implemented a Reverse Polish Notation calculator using linked lists from Lab Week 2? Well if you completed it you may have noticed that the typical algorithm uses properties of a stack. Now that you have learned how stacks work, try implementing a RPN with a stack!\n\n\nQueues\n\n\n\n\nThe word queue is pronounced \"Q\" because all the other letters are waiting their turn to be pronounced...\n\n\n\n\nQueues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.\n\n\nHere's a small demo of how queues work:\n\n\n#include \niostream\n\n#include \nqueue\n\n\nusing namespace std;\n\nint main() {\n  queue\nint\n q;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout \n \nPopping (\n \n q.front() \n \n)\n \n endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout \n \nqueue is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nRun it!!\n\n\nHere are some commonly used queue ADT operations:\n\n\n\n\n\n\n\n\nMember function\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npush(element)\n;\n\n\nInsert element\n\n\n\n\n\n\npop(element)\n;\n\n\nRemove top element\n\n\n\n\n\n\ntop()\n;\n\n\nAccess the top of the stack\n\n\n\n\n\n\nsize()\n;\n\n\nReturns the size\n\n\n\n\n\n\nempty()\n;\n\n\nReturns true if the container's size is 0, false otherwise", 
            "title": "Stacks & Queues"
        }, 
        {
            "location": "/lec_week_03/#stacks-and-queues", 
            "text": "", 
            "title": "Stacks and Queues"
        }, 
        {
            "location": "/lec_week_03/#stacks", 
            "text": "Stacks are  LIFO  (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.  Here's a small demo of how stacks work:  #include  iostream \n#include  stack \n\nusing namespace std;\n\nint main() {\n  stack int  s;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout    Popping (    s.top()    )    endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout    stack is empty    endl;\n\n  return 0;\n}  Try running that and see what is output.\nGo ahead. I'll wait.  Were you surprised by the output?  Here are some commonly used stack ADT operations:     Member function  Description      push(element) ;  Insert element    pop(element) ;  Remove top element    top() ;  Access the top of the stack    size() ;  Returns the size    empty() ;  Returns true if the container's size is 0, false otherwise     Quick Exercise: Remember how you implemented a Reverse Polish Notation calculator using linked lists from Lab Week 2? Well if you completed it you may have noticed that the typical algorithm uses properties of a stack. Now that you have learned how stacks work, try implementing a RPN with a stack!", 
            "title": "Stacks"
        }, 
        {
            "location": "/lec_week_03/#queues", 
            "text": "The word queue is pronounced \"Q\" because all the other letters are waiting their turn to be pronounced...   Queues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.  Here's a small demo of how queues work:  #include  iostream \n#include  queue \n\nusing namespace std;\n\nint main() {\n  queue int  q;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout    Popping (    q.front()    )    endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout    queue is empty    endl;\n\n  return 0;\n}  Run it!!  Here are some commonly used queue ADT operations:     Member function  Description      push(element) ;  Insert element    pop(element) ;  Remove top element    top() ;  Access the top of the stack    size() ;  Returns the size    empty() ;  Returns true if the container's size is 0, false otherwise", 
            "title": "Queues"
        }, 
        {
            "location": "/lec_week_03_pt2/", 
            "text": "Exceptions\n\n\nAn \nexception\n is a circumstance that a program was not designed to handle. They are useful for when you need your program to detect and handle errors that may occur during program execution.\n\n\nHere's an example of code without error checking:\n\n\n#include \niostream\n\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout \n \nEnter your height (in inches): \n;\n  cin \n height;\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout \n \nYour height is equivalant to: \n \n feet \n \n feet \n \n inches \n \n inches!\n \n endl;\n\n  return 0;\n}\n\n\n\n\nNow let's do some test with some edge cases and see what the program outputs:\n\n\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nYour height is equivalant to: -4 feet -6 inches!    //\n------- Oh no!\n\n\n\n\nSo what most of you have been doing to avoid this error is a good implementation of branches!\n\n\n#include \niostream\n\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout \n \nEnter your height (in inches): \n;\n  cin \n height;\n\n  //If the height is less than 0, output error message and return\n  if(height \n 0)\n  {\n    cout \n \nError! Invalid height!\n \n endl;\n    return 0;\n  }\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout \n \nYour height is equivalant to: \n \n feet \n \n feet \n \n inches \n \n inches!\n \n endl;\n\n  return 0;\n}\n\n\n\n\nNow let's test this new code with the same input:\n\n\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!                //\n----- Much better~\n\n\n\n\nA more sophisticated way of handling these errors are \nexception-handling constructs\n. Using these constructs allows us to keep error-checking code separate from our main code.\n\n\n//Exception handling construct\n\n//... means normal code\n//...\ntry\n{\n  //...\n\n  //If error detected\n  throw objectOfExceptionType;\n\n  //...\n\n}\ncatch (exceptionType execptionObject)\n{\n  //Handle exception, e.g., print message\n}\n//...\n\n\n\n\nException constructs have three parts:\n\n\n\n\nA \ntry\n block surrounds normal code, which is exited immediately if a throw statement executes.\n\n\nA \nthrow\n statement appears within a try block; if reached, execution jumps immediately to the end of the try block. The code is written so only error situations lead to reaching a throw. The throw statement provides an object of a particular type, such as an object of type \"runtime_error\", which is a class defined in the \nstdexcept\n library. The statement is said to throw an exception of the particular type. A throw statement's syntax is similar to a return statement.\n\n\nA \ncatch\n clause immediately follows a try block; if the catch was reached due to an exception thrown of the catch clause's parameter type, the clause executes. The clause is said to catch the thrown exception. A catch block is called a \nhandler\n because it handles an exception.\n\n\n\n\nHere's the earlier program using exception-handling constructs. Notice that the normal code flow is not obscured by error-checking/handling if-else statements.\n\n\n#include \niostream\n\n#include \nstdexcept\n  //Exception class\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n\n  try\n  {\n    //Get input\n    cout \n \nEnter your height (in inches): \n;\n    cin \n height;\n\n    if(height \n 0)\n    {\n      throw runtime_error(\nError! Invalid height!\n);\n    }\n\n    //Return converted height input\n    int feet = height / 12;\n    int inches = height % 12;\n    cout \n \nYour height is equivalant to: \n \n feet \n \n feet \n \n inches \n \n inches!\n \n endl;\n  }\n  catch(runtime_error \nexcpt)\n  {\n    //Print error message passed by throw statement\n    cout \n excpt.what() \n endl;\n  }\n\n  return 0;\n}\n\n\n\n\nOutput:\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!              \n\n\n\n\n\nExceptions with functions\n\n\nNow you may be thinking, why even use exceptions?\n\n\n\n\nWell, the power of exceptions becomes clearer when used within a function. If an exception is thrown within a function and not caught within that function, then the function is immediately exited and the calling function is checked for a handler, and so on up the function call hierarchy.\n\n\nHere's an expanded program where we utilize functions with execptions:\n\n\n#include \niostream\n\n#include \nstdexcept\n\nusing namespace std;\n\nvoid getHeight(int \n feet, int \n inches)\n{\n   int height = 0; // User defined weight\n\n   // Get user data\n   cout \n \nEnter height (in inches): \n;\n   cin \n height;\n\n   // Error checking, non-negative weight\n   if (height \n 0)\n   {\n      throw runtime_error(\nError! Invalid height!\n);\n   }\n\n   //Calculate conversions\n   feet = height / 12;\n   inches = height % 12;\n\n   return;\n}\n\nvoid getWeight(double \n kilograms)\n{\n  int weight; // User defined weight\n\n  //Get user Data\n  cout \n \nEnter weight (in pounds): \n;\n  cin \n weight;\n\n  if (weight \n 0)\n  {\n      throw runtime_error(\nError! Invalid weight!\n);\n  }\n\n  //Calculate conversions\n  kilograms = weight / 0.453592;\n\n  return;\n}\n\nint main()\n{\n  int feet, inches = 0;\n  double kilograms = 0;\n\n  try\n  {\n      //Get user data\n      getHeight(feet, inches);\n      getWeight(kilograms);\n\n      cout \n \nYour height is equivalant to: \n \n feet \n \n feet \n \n inches \n \n inches!\n \n endl\n           \n \nYour weight is equivalant to: \n \n kilograms \n \n kilograms!\n \n endl;\n  }\n  catch (runtime_error \n excpt)\n  {\n      cout \n excpt.what() \n endl;\n      cout \n \nCannot compute info.\n \n endl;\n  }\n\n  return 0;\n}\n\n\n\n\nIn the code above we added a part to take in the user's weight. We then separated the user input into two different functions, each throwing their own exception. Now let's look at the code output:\n\n\n//Valid input\nEnter height (in inches): 75\nEnter weight (in pounds): 150\nYour height is equivalant to: 6 feet 3 inches!\nYour weight is equivalant to: 330.694 kilograms!\n\n//Invalid height\nEnter height (in inches): -55\nError! Invalid height!\nCannot compute info.\n\n//Invalid weight\nEnter height (in inches): 75\nEnter weight (in pounds): -100\nError! Invalid weight!\nCannot compute info.\n\n\n\n\nMultiple Exceptions\n\n\n\n\n\n\nBut wait....there's more!...\n\n\n\n\n\n\nMultiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.\n\n\nException handling using multiple handlers:\n\n...\ntry\n{\n  ...\n  throw objectOfExceptionType1;\n  ...\n  throw objectOfExceptionType2;\n  ...\n  throw objectOfExceptionType3;\n  ...\n}\ncatch (excptType1 \n exceptObj1)\n{\n  //Handle type1\n}\ncatch (excptType2 \n exceptObj2)\n{\n  //Handle type2\n}\ncatch (...)\n{\n  //Default handler. Catches all other objects (e.g. type3)\n}\n...//Execution continues\n\n\n\n\nOne thing to note is that if exceptObj2 is a subclass of exceptObj1, then objectOfExceptionType2 will always be caught by the first catch exception. A \ncommon error\n is to place a catch block intended to handle exceptions of a base class before catch blocks intended to handle exceptions of a derived class, preventing the latter from ever executing.\n\n\nHere's an example of using multiple handles. Note that exceptions can also be nested!\n\n\n#include \niostream\n\n#include \nvector\n\n#include \nstdexcept\n\nusing namespace std;\n\nint main()\n{\n  vector\nint\n v(10);\n  int input = 0;\n  int secondInput = 0;\n  int thirdInput = 0;\n\n  try\n  {\n      //Try getting a positive number. If a negative number is entered,\n      //it will throw an exception but still continue to the code after the catch\n      try\n      {\n        cout \n \nEnter a positive number: \n;\n        cin \n input;\n\n        if(input \n 0)\n        {\n          throw logic_error(\ninput variable is invalid!\n);\n        }\n      }\n      catch (logic_error \n excpt)\n      {\n          cout \n \nLogic error!: \n \n excpt.what() \n endl;\n      }\n\n      //Get negative number from user\n      cout \n \nEnter a negative number: \n;\n      cin \n secondInput;\n\n      if(secondInput \n 0)\n      {\n        throw runtime_error(\nSecond input is not a negative number!\n);\n      }\n\n      //Get 0 from user\n      cout \n \nEnter 0: \n;\n      cin \n thirdInput;\n\n      if(thirdInput != 0)\n      {\n        throw -1;\n      }\n\n      //Attempt to access an out-of-range index\n      cout \n v.at(20) \n endl; //This will throw an out-of-range exception\n\n  }\n  catch (out_of_range \n excpt)\n  {\n      cout \n \nOut of range error!: \n \n excpt.what() \n endl;\n  }\n  catch (runtime_error \n excpt)\n  {\n      cout \n \nRuntime error!: \n \n excpt.what() \n endl;\n  }\n  catch (...)\n  {\n      cout \n \nNon-zero error!: User did not input a 0!\n \n endl;\n  }\n\n  return 0;\n}\n\n\n\n\nOutput:\n//Valid inputs\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid first input\nEnter a positive number: -1\nLogic error!: input variable is invalid!    //\n---- Note that the program still continues\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid second input\nEnter a positive number: 1\nEnter a negative number: 1\nRuntime error!: Second input is not a negative number!\n\n//Invalid third input\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 9999\nNon-zero error!: User did not input a 0!", 
            "title": "Exceptions"
        }, 
        {
            "location": "/lec_week_03_pt2/#exceptions", 
            "text": "An  exception  is a circumstance that a program was not designed to handle. They are useful for when you need your program to detect and handle errors that may occur during program execution.  Here's an example of code without error checking:  #include  iostream \nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout    Enter your height (in inches):  ;\n  cin   height;\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout    Your height is equivalant to:     feet     feet     inches     inches!    endl;\n\n  return 0;\n}  Now let's do some test with some edge cases and see what the program outputs:  //Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nYour height is equivalant to: -4 feet -6 inches!    // ------- Oh no!  So what most of you have been doing to avoid this error is a good implementation of branches!  #include  iostream \nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout    Enter your height (in inches):  ;\n  cin   height;\n\n  //If the height is less than 0, output error message and return\n  if(height   0)\n  {\n    cout    Error! Invalid height!    endl;\n    return 0;\n  }\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout    Your height is equivalant to:     feet     feet     inches     inches!    endl;\n\n  return 0;\n}  Now let's test this new code with the same input:  //Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!                // ----- Much better~  A more sophisticated way of handling these errors are  exception-handling constructs . Using these constructs allows us to keep error-checking code separate from our main code.  //Exception handling construct\n\n//... means normal code\n//...\ntry\n{\n  //...\n\n  //If error detected\n  throw objectOfExceptionType;\n\n  //...\n\n}\ncatch (exceptionType execptionObject)\n{\n  //Handle exception, e.g., print message\n}\n//...  Exception constructs have three parts:   A  try  block surrounds normal code, which is exited immediately if a throw statement executes.  A  throw  statement appears within a try block; if reached, execution jumps immediately to the end of the try block. The code is written so only error situations lead to reaching a throw. The throw statement provides an object of a particular type, such as an object of type \"runtime_error\", which is a class defined in the  stdexcept  library. The statement is said to throw an exception of the particular type. A throw statement's syntax is similar to a return statement.  A  catch  clause immediately follows a try block; if the catch was reached due to an exception thrown of the catch clause's parameter type, the clause executes. The clause is said to catch the thrown exception. A catch block is called a  handler  because it handles an exception.   Here's the earlier program using exception-handling constructs. Notice that the normal code flow is not obscured by error-checking/handling if-else statements.  #include  iostream \n#include  stdexcept   //Exception class\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n\n  try\n  {\n    //Get input\n    cout    Enter your height (in inches):  ;\n    cin   height;\n\n    if(height   0)\n    {\n      throw runtime_error( Error! Invalid height! );\n    }\n\n    //Return converted height input\n    int feet = height / 12;\n    int inches = height % 12;\n    cout    Your height is equivalant to:     feet     feet     inches     inches!    endl;\n  }\n  catch(runtime_error  excpt)\n  {\n    //Print error message passed by throw statement\n    cout   excpt.what()   endl;\n  }\n\n  return 0;\n}  Output:\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!", 
            "title": "Exceptions"
        }, 
        {
            "location": "/lec_week_03_pt2/#exceptions-with-functions", 
            "text": "Now you may be thinking, why even use exceptions?   Well, the power of exceptions becomes clearer when used within a function. If an exception is thrown within a function and not caught within that function, then the function is immediately exited and the calling function is checked for a handler, and so on up the function call hierarchy.  Here's an expanded program where we utilize functions with execptions:  #include  iostream \n#include  stdexcept \nusing namespace std;\n\nvoid getHeight(int   feet, int   inches)\n{\n   int height = 0; // User defined weight\n\n   // Get user data\n   cout    Enter height (in inches):  ;\n   cin   height;\n\n   // Error checking, non-negative weight\n   if (height   0)\n   {\n      throw runtime_error( Error! Invalid height! );\n   }\n\n   //Calculate conversions\n   feet = height / 12;\n   inches = height % 12;\n\n   return;\n}\n\nvoid getWeight(double   kilograms)\n{\n  int weight; // User defined weight\n\n  //Get user Data\n  cout    Enter weight (in pounds):  ;\n  cin   weight;\n\n  if (weight   0)\n  {\n      throw runtime_error( Error! Invalid weight! );\n  }\n\n  //Calculate conversions\n  kilograms = weight / 0.453592;\n\n  return;\n}\n\nint main()\n{\n  int feet, inches = 0;\n  double kilograms = 0;\n\n  try\n  {\n      //Get user data\n      getHeight(feet, inches);\n      getWeight(kilograms);\n\n      cout    Your height is equivalant to:     feet     feet     inches     inches!    endl\n              Your weight is equivalant to:     kilograms     kilograms!    endl;\n  }\n  catch (runtime_error   excpt)\n  {\n      cout   excpt.what()   endl;\n      cout    Cannot compute info.    endl;\n  }\n\n  return 0;\n}  In the code above we added a part to take in the user's weight. We then separated the user input into two different functions, each throwing their own exception. Now let's look at the code output:  //Valid input\nEnter height (in inches): 75\nEnter weight (in pounds): 150\nYour height is equivalant to: 6 feet 3 inches!\nYour weight is equivalant to: 330.694 kilograms!\n\n//Invalid height\nEnter height (in inches): -55\nError! Invalid height!\nCannot compute info.\n\n//Invalid weight\nEnter height (in inches): 75\nEnter weight (in pounds): -100\nError! Invalid weight!\nCannot compute info.", 
            "title": "Exceptions with functions"
        }, 
        {
            "location": "/lec_week_03_pt2/#multiple-exceptions", 
            "text": "But wait....there's more!...    Multiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.  Exception handling using multiple handlers:\n\n...\ntry\n{\n  ...\n  throw objectOfExceptionType1;\n  ...\n  throw objectOfExceptionType2;\n  ...\n  throw objectOfExceptionType3;\n  ...\n}\ncatch (excptType1   exceptObj1)\n{\n  //Handle type1\n}\ncatch (excptType2   exceptObj2)\n{\n  //Handle type2\n}\ncatch (...)\n{\n  //Default handler. Catches all other objects (e.g. type3)\n}\n...//Execution continues  One thing to note is that if exceptObj2 is a subclass of exceptObj1, then objectOfExceptionType2 will always be caught by the first catch exception. A  common error  is to place a catch block intended to handle exceptions of a base class before catch blocks intended to handle exceptions of a derived class, preventing the latter from ever executing.  Here's an example of using multiple handles. Note that exceptions can also be nested!  #include  iostream \n#include  vector \n#include  stdexcept \nusing namespace std;\n\nint main()\n{\n  vector int  v(10);\n  int input = 0;\n  int secondInput = 0;\n  int thirdInput = 0;\n\n  try\n  {\n      //Try getting a positive number. If a negative number is entered,\n      //it will throw an exception but still continue to the code after the catch\n      try\n      {\n        cout    Enter a positive number:  ;\n        cin   input;\n\n        if(input   0)\n        {\n          throw logic_error( input variable is invalid! );\n        }\n      }\n      catch (logic_error   excpt)\n      {\n          cout    Logic error!:     excpt.what()   endl;\n      }\n\n      //Get negative number from user\n      cout    Enter a negative number:  ;\n      cin   secondInput;\n\n      if(secondInput   0)\n      {\n        throw runtime_error( Second input is not a negative number! );\n      }\n\n      //Get 0 from user\n      cout    Enter 0:  ;\n      cin   thirdInput;\n\n      if(thirdInput != 0)\n      {\n        throw -1;\n      }\n\n      //Attempt to access an out-of-range index\n      cout   v.at(20)   endl; //This will throw an out-of-range exception\n\n  }\n  catch (out_of_range   excpt)\n  {\n      cout    Out of range error!:     excpt.what()   endl;\n  }\n  catch (runtime_error   excpt)\n  {\n      cout    Runtime error!:     excpt.what()   endl;\n  }\n  catch (...)\n  {\n      cout    Non-zero error!: User did not input a 0!    endl;\n  }\n\n  return 0;\n}  Output:\n//Valid inputs\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid first input\nEnter a positive number: -1\nLogic error!: input variable is invalid!    // ---- Note that the program still continues\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid second input\nEnter a positive number: 1\nEnter a negative number: 1\nRuntime error!: Second input is not a negative number!\n\n//Invalid third input\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 9999\nNon-zero error!: User did not input a 0!", 
            "title": "Multiple Exceptions"
        }, 
        {
            "location": "/lec_week_03_pt3/", 
            "text": "Templates\n\n\nYou may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node.\n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode * next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};\n\n\n\n\nThat's all fine and dandy, but if instead want a \nDoubleList\n or a\n\nStringList\n, then we are in trouble.\n\n\nA common first instinct is to copy-and-paste code manually\nand change the types where needed. But even expert programmers\nstart to \nmake mistakes\n\ncopy and pasting.\n\n\nIntroducing templates!\n\n\nThe solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.\n\n\nIn fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.\n\n\nTo create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".\n\n\nvector\nint\n numbers; // creates a vector of integers\nvector\nstring\n words; // creates a vector of strings\n\n\n\n\nTo create a new class template, before our class declaration we use the keyword \ntemplate\n followed by a type parameter inside \"angle-brackets\"\ne.g. \ntemplate\ntypename T\n. The keyword \ntypename\n tells the compiler\nthat \nT\n is a placeholder for an actual type.\n\n\nNote: \nT\n is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is \nContainer\n\n\nLet's say, we want to create a templated version of our Node and List.\n\n\nIntNode\n becomes:\n\n\ntemplate\ntypename T\n\nstruct Node {\n   T val;\n   Node\nT\n * next;\n};\n\n\n\n\nand \nIntLinkedList\n becomes:\n\n\ntemplate\ntypename T\n\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node\nT\n * head;\n};\n\n\n\n\nTo create a \nLinkedList\n of doubles, we declare the list as so:\n\n\nLinkedList\ndouble\n list;\n\n\n\n\nIn order to template functions and method, we do something similar.\n\n\nFor example, if we want to define the templated LinkedList's\n\npush_front\n method:\n\n\ntemplate\ntypename T\n\nLinkedList\nT\n::push_front(T val) {\n    Node * new_node = new Node\nT\n();\n    new_node -\n val = val;\n\n    Node * old_head = this -\n head;\n    new_node -\n next = old_head;\n    this -\n head = new_node;\n}\n\n\n\n\nFor more info on templates check out \nthis FAQ\n!\n\n\nExercises\n\n\nImplement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!\n\n\nPro-Tip: before implementing the class as a class template, \ntypedef\n the type \nT\n as an integer and replace type with \nT\n as needed.\n\ne.g.\n\n\ntypedef int T; // give the int an alias which is T\nT my_int = 42;\n\n\n\n\nThis give you much nicer error messages and makes it easier to debug.\n\n\nExample Usage, should implement at least the following methods:\n\n\nMyVector\nstring\n vec;\nvec.push_back(\nCS14\n);\nvec.push_back(\nWorld\n);\nvec.insert(\nHello\n, 0);\ncout \n vec.front() \n endl; // \nHello\n\ncout \n vec.back() \n endl; // \nWorld\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nCS14\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nHello\n\n\nMyVector\nint\n another_vec;\nanother_vec.push_back(42);\n\n\n\n\nStretch-goal exercise:\n\n\nRewrite your IntList as a class template!", 
            "title": "Templates"
        }, 
        {
            "location": "/lec_week_03_pt3/#templates", 
            "text": "You may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".  In order to implement a Linked List, you must define the structure\nfor an individual node.  For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode * next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};  That's all fine and dandy, but if instead want a  DoubleList  or a StringList , then we are in trouble.  A common first instinct is to copy-and-paste code manually\nand change the types where needed. But even expert programmers\nstart to  make mistakes \ncopy and pasting.", 
            "title": "Templates"
        }, 
        {
            "location": "/lec_week_03_pt3/#introducing-templates", 
            "text": "The solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.  In fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.  To create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".  vector int  numbers; // creates a vector of integers\nvector string  words; // creates a vector of strings  To create a new class template, before our class declaration we use the keyword  template  followed by a type parameter inside \"angle-brackets\"\ne.g.  template typename T . The keyword  typename  tells the compiler\nthat  T  is a placeholder for an actual type.  Note:  T  is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is  Container  Let's say, we want to create a templated version of our Node and List.  IntNode  becomes:  template typename T \nstruct Node {\n   T val;\n   Node T  * next;\n};  and  IntLinkedList  becomes:  template typename T \nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node T  * head;\n};  To create a  LinkedList  of doubles, we declare the list as so:  LinkedList double  list;  In order to template functions and method, we do something similar.  For example, if we want to define the templated LinkedList's push_front  method:  template typename T \nLinkedList T ::push_front(T val) {\n    Node * new_node = new Node T ();\n    new_node -  val = val;\n\n    Node * old_head = this -  head;\n    new_node -  next = old_head;\n    this -  head = new_node;\n}  For more info on templates check out  this FAQ !", 
            "title": "Introducing templates!"
        }, 
        {
            "location": "/lec_week_03_pt3/#exercises", 
            "text": "Implement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!  Pro-Tip: before implementing the class as a class template,  typedef  the type  T  as an integer and replace type with  T  as needed. \ne.g.  typedef int T; // give the int an alias which is T\nT my_int = 42;  This give you much nicer error messages and makes it easier to debug.  Example Usage, should implement at least the following methods:  MyVector string  vec;\nvec.push_back( CS14 );\nvec.push_back( World );\nvec.insert( Hello , 0);\ncout   vec.front()   endl; //  Hello \ncout   vec.back()   endl; //  World \nvec.pop_back();\ncout   vec.back()   endl; //  CS14 \nvec.pop_back();\ncout   vec.back()   endl; //  Hello \n\nMyVector int  another_vec;\nanother_vec.push_back(42);", 
            "title": "Exercises"
        }, 
        {
            "location": "/lec_week_03_pt3/#stretch-goal-exercise", 
            "text": "Rewrite your IntList as a class template!", 
            "title": "Stretch-goal exercise:"
        }, 
        {
            "location": "/lab_week_03/", 
            "text": "Lab 3: Templates and Exceptions\n\n\nExercise 1 - Queue with two Stacks\n\n\nYour task is to implement a class called \nQueue\n using two stacks \nstd::stack\n.\n\n\nPublic Methods\n\n\nQueue(int c = 256) {cap = c; sz = 0}\nvoid printAll()\nvoid push_q(data_type t)\ndata_type pop_q() // removes and returns the top element\nbool isEmpty() \n\n\n\n\nPrivate Data Fields\n\n\nstack\ndata_type\n s1;\nstack\ndata_type\n s2;\nunsigned sz;  // the number of elements currently being used in Queue\nunsigned cap; // the size of Queue\n\n\n\n\nExercise 1.1 - Template Queue\n\n\nTake your completed queue class and create a queue template to allow your class to have members that use template parameters as types.\n\nQueue\n should now become:\n\n\ntemplate\ntypename T\n\nclass Queue\n{\n    public:\n        // ...  \n    private: \n        // ...\n};\n\n\n\n\nand \nprintAll()\n should now become:\n\n\ntemplate\ntypename T\n\nvoid Queue\nT\n::printAll()\n{\n    // ...\n}\n\n\n\n\nExercise 1.2 - Exceptions\n\n\nAdd an exception handler that throws a \nruntime_error\n object in the \npop_q()\n and \npush_q()\n function that is caught and handled in the main program. \nDetermine what conditions in \npop_q()\n and \npush_q\n would cause an exception to be thrown.\nWhen the exception is caught in the main program, print the error message passed by throw statement and continue the program. Do not terminate. \n\n\nmain\n should look like the following:\n\n\nint main()\n{\n    string s = \nabcde\n;\n    Queue\nchar\n q(s.size());\n    try \n    {\n        // ...\n    }\n    catch ( ... )\n    {\n       // ...\n    }\n\n    return 0;\n}\n\n\n\n\nExample\n\n\nExceptions are not implemented in this example.\n\n\nint main()\n{\n    string s = \nabcde\n;\n    Queue\nchar\n q(s.size());\n    for(unsigned i = 0; i \n s.size(); ++i)\n    {\n        q.push_q(s.at(i));\n    }\n    q.printAll();\n\n    for(unsigned i = 0; i \n 3; ++i)\n    {\n        q.pop_q();\n        q.printAll();\n    }\n    q.push_q('x');\n    q.printAll();\n    q.push_q('y');\n    q.printAll();\n\n    return 0;\n}\n\n\n\n\nOutput (first element is the top element): \n\n\na b c d e \nb c d e \nc d e \nd e \nd e x \nd e x y", 
            "title": "Lab Week 3"
        }, 
        {
            "location": "/lab_week_03/#lab-3-templates-and-exceptions", 
            "text": "", 
            "title": "Lab 3: Templates and Exceptions"
        }, 
        {
            "location": "/lab_week_03/#exercise-1-queue-with-two-stacks", 
            "text": "Your task is to implement a class called  Queue  using two stacks  std::stack .  Public Methods  Queue(int c = 256) {cap = c; sz = 0}\nvoid printAll()\nvoid push_q(data_type t)\ndata_type pop_q() // removes and returns the top element\nbool isEmpty()   Private Data Fields  stack data_type  s1;\nstack data_type  s2;\nunsigned sz;  // the number of elements currently being used in Queue\nunsigned cap; // the size of Queue", 
            "title": "Exercise 1 - Queue with two Stacks"
        }, 
        {
            "location": "/lab_week_03/#exercise-11-template-queue", 
            "text": "Take your completed queue class and create a queue template to allow your class to have members that use template parameters as types. Queue  should now become:  template typename T \nclass Queue\n{\n    public:\n        // ...  \n    private: \n        // ...\n};  and  printAll()  should now become:  template typename T \nvoid Queue T ::printAll()\n{\n    // ...\n}", 
            "title": "Exercise 1.1 - Template Queue"
        }, 
        {
            "location": "/lab_week_03/#exercise-12-exceptions", 
            "text": "Add an exception handler that throws a  runtime_error  object in the  pop_q()  and  push_q()  function that is caught and handled in the main program. \nDetermine what conditions in  pop_q()  and  push_q  would cause an exception to be thrown.\nWhen the exception is caught in the main program, print the error message passed by throw statement and continue the program. Do not terminate.   main  should look like the following:  int main()\n{\n    string s =  abcde ;\n    Queue char  q(s.size());\n    try \n    {\n        // ...\n    }\n    catch ( ... )\n    {\n       // ...\n    }\n\n    return 0;\n}", 
            "title": "Exercise 1.2 - Exceptions"
        }, 
        {
            "location": "/lab_week_03/#example", 
            "text": "Exceptions are not implemented in this example.  int main()\n{\n    string s =  abcde ;\n    Queue char  q(s.size());\n    for(unsigned i = 0; i   s.size(); ++i)\n    {\n        q.push_q(s.at(i));\n    }\n    q.printAll();\n\n    for(unsigned i = 0; i   3; ++i)\n    {\n        q.pop_q();\n        q.printAll();\n    }\n    q.push_q('x');\n    q.printAll();\n    q.push_q('y');\n    q.printAll();\n\n    return 0;\n}  Output (first element is the top element):   a b c d e \nb c d e \nc d e \nd e \nd e x \nd e x y", 
            "title": "Example"
        }, 
        {
            "location": "/lab_week_04/", 
            "text": "Lab 4: Trees\n\n\nExercise 1 - Binary Search Trees\n\n\nToday we will be working on implementing a BST. \n\n\nWe've written the foundation for a program to create a Tree, so all you have to do fill in the remaining function implementations!\n\n\nNote, since we're giving you a precompiled file, you're going to have to use C9 for this exercise\n\n\nHow to get the code\n\n\nIn your C9 terminal, run the following in the directory where you want the code\n\n\ngit clone https://github.com/scohe001/Tree\n\n\n\nYou'll notice you now have a \nmain\n, and a \nTree\n class.\n\n\nWe've already completed most of the implementation of the \nTree\n class for you. The details for doing the blanks so are in the comments, so don't just delete them!\n\n\nCompiling\n\n\nSince we're using C++11 features, you'll have to compile with the following:\n\n\ng++ -std=c++11 -Wall main.cpp Tree.cpp\n\n\n\nPart 1: Printing the tree\n\n\nImplement the print recursive function to print all of the values of the tree in order.\n\n\nTree test = {5, 2, 7, 3, 8, 3, 7};\nprint(\nPrinting!\n, MAGENTA);\ncout \n endl;\ntest.print();\n\n\n\n\nThe output should look like the following:\n\n\nPrinting!\n2 3 5 7 8 \n\n\n\n\nPart 2: Maximum and Minimum\n\n\nImplement recurisve min and max functions to find the min and max value in the tree whose root is the parameter.\n\n\nTree test = {5, 2, 7, 3, 8, 3, 7};\nNode* min = test.min();\nNode* max = test.max();\ncout \n \nMin: \n \n min-\nval \n endl \n \nMax: \n \n max-\nval \n endl;\n\n\n\n\nThe output should look like the following:\n\n\nMin: 2\nMax: 8\n\n\n\n\nPart 3: Find\n\n\nImplement the find recursive function to find a value in the tree and return it's node pointer (returning 0 if not found).\n\n\nTree test = {5, 2, 7, 3, 8, 3, 7};\nNode* f1 = test.find(6);\nNode* f2 = test.find(7);\n\n\n\n\nBe sure to notify the user whether or not the value is found. \n\n\nPart 4: Conversion\n\n\nImplement a to_vec function that converts the tree to a vector and returns the sorted vector of tree values.\n\n\nTree test = {5, 2, 7, 3, 8, 3, 7};\nvector\nint\n v = test.to_vector();\n\n\n\n\nThe vector should contain the following values (in this order): 2 3 5 7 8", 
            "title": "Lab Week 4"
        }, 
        {
            "location": "/lab_week_04/#lab-4-trees", 
            "text": "", 
            "title": "Lab 4: Trees"
        }, 
        {
            "location": "/lab_week_04/#exercise-1-binary-search-trees", 
            "text": "Today we will be working on implementing a BST.   We've written the foundation for a program to create a Tree, so all you have to do fill in the remaining function implementations!  Note, since we're giving you a precompiled file, you're going to have to use C9 for this exercise", 
            "title": "Exercise 1 - Binary Search Trees"
        }, 
        {
            "location": "/lab_week_04/#how-to-get-the-code", 
            "text": "In your C9 terminal, run the following in the directory where you want the code  git clone https://github.com/scohe001/Tree  You'll notice you now have a  main , and a  Tree  class.  We've already completed most of the implementation of the  Tree  class for you. The details for doing the blanks so are in the comments, so don't just delete them!", 
            "title": "How to get the code"
        }, 
        {
            "location": "/lab_week_04/#compiling", 
            "text": "Since we're using C++11 features, you'll have to compile with the following:  g++ -std=c++11 -Wall main.cpp Tree.cpp", 
            "title": "Compiling"
        }, 
        {
            "location": "/lab_week_04/#part-1-printing-the-tree", 
            "text": "Implement the print recursive function to print all of the values of the tree in order.  Tree test = {5, 2, 7, 3, 8, 3, 7};\nprint( Printing! , MAGENTA);\ncout   endl;\ntest.print();  The output should look like the following:  Printing!\n2 3 5 7 8", 
            "title": "Part 1: Printing the tree"
        }, 
        {
            "location": "/lab_week_04/#part-2-maximum-and-minimum", 
            "text": "Implement recurisve min and max functions to find the min and max value in the tree whose root is the parameter.  Tree test = {5, 2, 7, 3, 8, 3, 7};\nNode* min = test.min();\nNode* max = test.max();\ncout    Min:     min- val   endl    Max:     max- val   endl;  The output should look like the following:  Min: 2\nMax: 8", 
            "title": "Part 2: Maximum and Minimum"
        }, 
        {
            "location": "/lab_week_04/#part-3-find", 
            "text": "Implement the find recursive function to find a value in the tree and return it's node pointer (returning 0 if not found).  Tree test = {5, 2, 7, 3, 8, 3, 7};\nNode* f1 = test.find(6);\nNode* f2 = test.find(7);  Be sure to notify the user whether or not the value is found.", 
            "title": "Part 3: Find"
        }, 
        {
            "location": "/lab_week_04/#part-4-conversion", 
            "text": "Implement a to_vec function that converts the tree to a vector and returns the sorted vector of tree values.  Tree test = {5, 2, 7, 3, 8, 3, 7};\nvector int  v = test.to_vector();  The vector should contain the following values (in this order): 2 3 5 7 8", 
            "title": "Part 4: Conversion"
        }, 
        {
            "location": "/lec_week_04/", 
            "text": "Binary Search Trees (BST)\n\n\n\n\n\n\n\n\nWhat's a tree?\n\n\nTrees are often easier to deal with recursively (or if you're a mathematician, 'inductively').\nThus, to define a tree recursively, we can say that:\n\n\n\n\nA Tree is a system of \nnodes\n\n\nA node consists of a value and pointers to its children\n\n\nAn \nInternal Node\n is a node with at least one child\n\n\n\n\n\n\nEvery node has a unique \nparent\n\n\nA node with a child is said to be that child's parent\n\n\nA node's \nancestor\n include the node's parent, the parent's parent, ect., up to the tree's root\n\n\nNo node has more than one parent\n\n\n\n\n\n\nThe \nRoot\n of a tree has no parent\n\n\nA Node can have any number of children (including 0)\n\n\n\n\nWhen we put all of these things together, we end up with something looking like:\n\n\n\n\nWhere the numbers in the nodes represent the value at that node, and the arrows represent pointers to children nodes.\n\n\nHere are a few additional terms that are good to know about trees:\n\n\n\n\nThe link from a node to a child is called an \nedge\n.\n\n\nA node's \ndepth\n is the number of edges on the path from the root to the node. The root node thus has depth 0.\n\n\nAll nodes with the same depth form a tree \nlevel\n.\n\n\nA tree's \nheight\n is the largest depth of any node. A tree with just one node has height 0.\n\n\n\n\nWhat's a BST?\n\n\nA Binary Search Tree is exactly like any other tree, except every node has \nexactly\n two children (if there is no child, the node will be a null pointer).\nFurtermore (and more importantly), every child to the left of a node will be less than the node, while every child to the right will be greater.\n\n\nYou'll notice that the picture above is \nNOT\n a BST. Even though each node has two children (we can pretend that there are invisible null children), if we go to the left child of our root, we find a value that is \ngreater\n, breaking our definition.\n\n\nThis\n would be a valid Binary Search Tree:\n\n\n\n\nNotice how \nevery\n number to the left of any node (take 8 for example), is less than the node itself (1, 3, 4, 5, 7). Since this is the case, where will the smallest node be? What about the largest?\n\n\nBST Searching algorithm\n\n\nGiven a key, a search algorithm returns the first node found matching that key, or returns 0 if a matching node is not found. A simple BST search algorithm checks the current node (initially the tree's root), returning that node as a match, else assigning the current node with the left (if key is less) or right (if key is greater) child and repeating. If such a child is 0, the algorithm returns 0 (matching node not found).\n\n\nHere's an example of how powerful a BST can be. If we have a BST and a sorted array, searching for a specific number can be much faster.\n\n\n\n\nBST Insert Algorithm\n\n\nGiven a new node, a BST insert operation inserts the new node in a proper location obeying the BST ordering property. A simple BST insert algorithm compares the new node with the current node (initially the root):\n\n\n\n\nInsert as left child:\n If the new node's key is less than the current node, and the current node's left child is 0, the algorithm assigns that node's left child with the new node.\n\n\nInsert as right child:\n If the new node's key is greater than the current node, and the current node's right child is 0, the algorithm assigns the node's right child with the new node.\n\n\nSearch for insert location:\n If the left (or right) child is not 0, the algorithm assigns the current node with that child and continues searching for a proper insert location.\n\n\n\n\nHere's an animated example of BST insertion:\n\n\n\n\nBST Delete Algorithm\n\n\nDeletion in a BST is a bit tedious as compared to Insertion and searching. This is because the resultant tree after deleting a node from a BST must also be a BST (it should preserve the BST property).\n\n\nGiven a key, a BST remove operation removes the first-found matching node, restructuring the tree to preserve the BST ordering property. The algorithm first searches for a matching node just like the search algorithm. If found (call this node X), the algorithm performs one of the following sub-algorithms:\n\n\n\n\nRemove a leaf node:\n If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with 0. Else, if X was the root, the root pointer is assigned with 0, and the BST is now empty.\n\n\n\nRemove an internal node with single child:\n If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with X's single child. Else, if X was the root, the root pointer is assigned with X's single child.\n\n\n\nRemove an internal node with two children:\n This case is the hardest. First, the algorithm locates X's successor (the leftmost child of X's right subtree), and copies the successor to X. Then, the algorithm recursively removes the successor from the right subtree.\n\n\n\n\n\nPut it into practice!\n\n\nWe have created a \nsimple implementation of a BST\n for you to use. The class comes with the member functions \nvoid push(T val)\n to add values to the tree, and \nvoid print()\n to print a rough representation of the tree.\n\n\nNOTE:\n\n\nIt is often almost always easier to write Tree functions recursively (as you'll see the push function has been written). However, it \nis\n possible to do all of the following exercises without recursion--you'll just need to be iterating over a stack you're constantly pushing and popping to (as you'll see the print function is doing).", 
            "title": "Lecture Week 4"
        }, 
        {
            "location": "/lec_week_04/#binary-search-trees-bst", 
            "text": "", 
            "title": "Binary Search Trees (BST)"
        }, 
        {
            "location": "/lec_week_04/#whats-a-tree", 
            "text": "Trees are often easier to deal with recursively (or if you're a mathematician, 'inductively').\nThus, to define a tree recursively, we can say that:   A Tree is a system of  nodes  A node consists of a value and pointers to its children  An  Internal Node  is a node with at least one child    Every node has a unique  parent  A node with a child is said to be that child's parent  A node's  ancestor  include the node's parent, the parent's parent, ect., up to the tree's root  No node has more than one parent    The  Root  of a tree has no parent  A Node can have any number of children (including 0)   When we put all of these things together, we end up with something looking like:   Where the numbers in the nodes represent the value at that node, and the arrows represent pointers to children nodes.  Here are a few additional terms that are good to know about trees:   The link from a node to a child is called an  edge .  A node's  depth  is the number of edges on the path from the root to the node. The root node thus has depth 0.  All nodes with the same depth form a tree  level .  A tree's  height  is the largest depth of any node. A tree with just one node has height 0.", 
            "title": "What's a tree?"
        }, 
        {
            "location": "/lec_week_04/#whats-a-bst", 
            "text": "A Binary Search Tree is exactly like any other tree, except every node has  exactly  two children (if there is no child, the node will be a null pointer).\nFurtermore (and more importantly), every child to the left of a node will be less than the node, while every child to the right will be greater.  You'll notice that the picture above is  NOT  a BST. Even though each node has two children (we can pretend that there are invisible null children), if we go to the left child of our root, we find a value that is  greater , breaking our definition.  This  would be a valid Binary Search Tree:   Notice how  every  number to the left of any node (take 8 for example), is less than the node itself (1, 3, 4, 5, 7). Since this is the case, where will the smallest node be? What about the largest?", 
            "title": "What's a BST?"
        }, 
        {
            "location": "/lec_week_04/#bst-searching-algorithm", 
            "text": "Given a key, a search algorithm returns the first node found matching that key, or returns 0 if a matching node is not found. A simple BST search algorithm checks the current node (initially the tree's root), returning that node as a match, else assigning the current node with the left (if key is less) or right (if key is greater) child and repeating. If such a child is 0, the algorithm returns 0 (matching node not found).  Here's an example of how powerful a BST can be. If we have a BST and a sorted array, searching for a specific number can be much faster.", 
            "title": "BST Searching algorithm"
        }, 
        {
            "location": "/lec_week_04/#bst-insert-algorithm", 
            "text": "Given a new node, a BST insert operation inserts the new node in a proper location obeying the BST ordering property. A simple BST insert algorithm compares the new node with the current node (initially the root):   Insert as left child:  If the new node's key is less than the current node, and the current node's left child is 0, the algorithm assigns that node's left child with the new node.  Insert as right child:  If the new node's key is greater than the current node, and the current node's right child is 0, the algorithm assigns the node's right child with the new node.  Search for insert location:  If the left (or right) child is not 0, the algorithm assigns the current node with that child and continues searching for a proper insert location.   Here's an animated example of BST insertion:", 
            "title": "BST Insert Algorithm"
        }, 
        {
            "location": "/lec_week_04/#bst-delete-algorithm", 
            "text": "Deletion in a BST is a bit tedious as compared to Insertion and searching. This is because the resultant tree after deleting a node from a BST must also be a BST (it should preserve the BST property).  Given a key, a BST remove operation removes the first-found matching node, restructuring the tree to preserve the BST ordering property. The algorithm first searches for a matching node just like the search algorithm. If found (call this node X), the algorithm performs one of the following sub-algorithms:   Remove a leaf node:  If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with 0. Else, if X was the root, the root pointer is assigned with 0, and the BST is now empty.  Remove an internal node with single child:  If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with X's single child. Else, if X was the root, the root pointer is assigned with X's single child.  Remove an internal node with two children:  This case is the hardest. First, the algorithm locates X's successor (the leftmost child of X's right subtree), and copies the successor to X. Then, the algorithm recursively removes the successor from the right subtree.", 
            "title": "BST Delete Algorithm"
        }, 
        {
            "location": "/lec_week_04/#put-it-into-practice", 
            "text": "We have created a  simple implementation of a BST  for you to use. The class comes with the member functions  void push(T val)  to add values to the tree, and  void print()  to print a rough representation of the tree.", 
            "title": "Put it into practice!"
        }, 
        {
            "location": "/lec_week_04/#note", 
            "text": "It is often almost always easier to write Tree functions recursively (as you'll see the push function has been written). However, it  is  possible to do all of the following exercises without recursion--you'll just need to be iterating over a stack you're constantly pushing and popping to (as you'll see the print function is doing).", 
            "title": "NOTE:"
        }
    ]
}