{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-cs14-si",
            "text": "This is where all of the labs will be posted.",
            "title": "Welcome to CS14 SI!"
        },
        {
            "location": "/#what-is-si",
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.",
            "title": "What is SI?"
        },
        {
            "location": "/#what-isnt-si",
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.",
            "title": "What isn\u2019t SI?"
        },
        {
            "location": "/#who-should-go",
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.",
            "title": "Who should go?"
        },
        {
            "location": "/#guidelines",
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).",
            "title": "Guidelines:"
        },
        {
            "location": "/lec_week_02/",
            "text": "Lecture 2: Lists\n\n\nQuestion of the day!\n\n\n\n\nHow many programmers does it take to change a light bulb?\n\n\n\n\n\n\n\n\nNone. That's a hardware problem.\n\n\n\n\n\n\n\n\n\n\nLists\n\n\nAn \nabstract data type (ADT)\n is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.\n\n\nLists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a \nnode\n.\n\n\nSingly-linked Lists\n\n\nSingly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the \nhead\n, and the last node is the \ntail\n.\n\n\n\n    The head in this case would be the node with value 12 and the tail would be the node with value 37\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node.\n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};\n\n\n\n\nDoubly Linked List\n\n\nIn a doubly linked list, each node contains three parts:\n\n\n\n\nData\n\n\nPointer to the next node\n\n\nPointer to the previous node\n\n\n\n\n\n\nIn this case, our new struct may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};\n\n\n\n\nDummy Nodes\n\n\nSometimes, to make edge cases easier to handle, dummy nodes are used at the end of lists. For example:\n\n\n\n\nIn this image the list is of size 1, however there are three nodes. This is because the\nfirst and the last nodes are \"Dummy Nodes.\" Dummy Nodes are there to make lists \neasier to use. For example, without dummy nodes, writting a function typically requires\naccounting for the special cases such as when the list is empty or size one.\nTake for example the following code for a push back and pop front for a singly-linked\nlist with only a head pointer.\n\n\nvoid IntList :: pushBack(int n){\n    if(head == 0){\n        head = new Node(n);\n        return;\n    }\n    Node* loop = 0;\n    for(loop = head; loop->next != 0; loop = loop->next){}\n    loop->next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head == 0){\n        return; // list is empty\n    }\n    else if(head->next == 0){\n        delete head;\n        head = 0;\n    }\n    else{\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\n\n\n\nUsing Dummy nodes, we can reduce this code to the following:\n\n\nvoid IntList :: pushBack(int n){\n    Node* loop = 0;\n    for(loop = head; loop->next != 0; loop = loop->next){}\n    loop->next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head->next == 0){\n        return; //list is empty\n    }\n    else{\n        Node* temp = head->next;\n        head->next = temp->next;\n        delete temp;\n    }\n}\n\n\n\n\nNotice how in both functions, the \nif(head == 0)\n is no longer a case we have to check for\n(since head will never be 0). This helps simplify the code and handle common edge cases.\n\n\nOther functions must of course also be changed such as the print function, but the overall\ncomplexity of the code decreases. The contents of the dummy node don't matter as they shouldn't\never be seen.\n\n\nExercise 1: Fibonacci Exercise\n\n\nFn = Fn-1 + Fn-2\n\n\nF0 = 0, F1 = 1\n\n\nWrite a program that will calculate a specified fibonacci number using the \nstd::list data\n\nstructure. Think about how to use a list to store values of the formula above.\n\n\n\n\nInput:    integer n\n\n\nOutput:   nth Fibonacci number\n\n\n\n\nExample:\n\n\n\n\nWhich Fibonacci number to calculate: \n10\n\n\n10th Fibonacci number: \n55\n\n\n\n\nExercise 2: Palindrome Exercise\n\n\nWrite a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.\n\n\n\n\nInput:    string input\n\n\nOutput:   result of the palindrome test\n\n\n\n\nExample:\n\n\n\n\nEnter a word to test for palindrome: \ntacocats\n\n\ntacocats\n is not a palindrome.\n\n\n\n\nKey functions to incorporate: back(), pop_back()\n\n\nExercise 3: Animation!\n\n\nWe've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!\n\n\nAt the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into \ncout\n!\n\n\nNote, since we're giving you a precompiled file, you're going to have to use C9 for this exercise\n\n\nHow to get the code\n\n\nIn your C9 terminal, run the following in the directory where you want the code\n\n\ngit clone https://github.com/scohe001/Animations\n\n\n\nYou'll notice you now have a \nmain\n, an \nAnimator\n class and a couple animation files (don't look at them yet, it'll ruin the surprise!\n*\n).\n\n\nWe've already completely implemented the \nAnimator\n class for you and compiled it, so all you'll have to do is finish off the \nmain\n skeleton! The details for doing so are in the comments, so don't just delete them!\n\n\nCompiling\n\n\nSince we're using C++11 features and threading, you'll have to compile with the following:\n\n\ng++ -std=c++11 -pthread -Wall main.cpp animation.o\n\n\n\nAfter you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!\n\n\nOnce you have all of the animations working, delete \nanimation.o\n and use the skeleton \nanimation.cpp\n we've given you to complete the \nAnimation\n class! Recompiling the \nAnimation\n class should look like the following:\n\n\ng++ -std=c++11 -pthread -c animation.cpp\n\n\n\n*\n Since you're all CS majors I'm sure the lot of you have already looked at them >.>",
            "title": "Lecture Week 2"
        },
        {
            "location": "/lec_week_02/#lecture-2-lists",
            "text": "",
            "title": "Lecture 2: Lists"
        },
        {
            "location": "/lec_week_02/#question-of-the-day",
            "text": "How many programmers does it take to change a light bulb?     None. That's a hardware problem.",
            "title": "Question of the day!"
        },
        {
            "location": "/lec_week_02/#lists",
            "text": "An  abstract data type (ADT)  is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.  Lists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a  node .",
            "title": "Lists"
        },
        {
            "location": "/lec_week_02/#singly-linked-lists",
            "text": "Singly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the  head , and the last node is the  tail .  \n    The head in this case would be the node with value 12 and the tail would be the node with value 37  In order to implement a Linked List, you must define the structure\nfor an individual node.  For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};",
            "title": "Singly-linked Lists"
        },
        {
            "location": "/lec_week_02/#doubly-linked-list",
            "text": "In a doubly linked list, each node contains three parts:   Data  Pointer to the next node  Pointer to the previous node    In this case, our new struct may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};",
            "title": "Doubly Linked List"
        },
        {
            "location": "/lec_week_02/#dummy-nodes",
            "text": "Sometimes, to make edge cases easier to handle, dummy nodes are used at the end of lists. For example:   In this image the list is of size 1, however there are three nodes. This is because the\nfirst and the last nodes are \"Dummy Nodes.\" Dummy Nodes are there to make lists \neasier to use. For example, without dummy nodes, writting a function typically requires\naccounting for the special cases such as when the list is empty or size one.\nTake for example the following code for a push back and pop front for a singly-linked\nlist with only a head pointer.  void IntList :: pushBack(int n){\n    if(head == 0){\n        head = new Node(n);\n        return;\n    }\n    Node* loop = 0;\n    for(loop = head; loop->next != 0; loop = loop->next){}\n    loop->next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head == 0){\n        return; // list is empty\n    }\n    else if(head->next == 0){\n        delete head;\n        head = 0;\n    }\n    else{\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}  Using Dummy nodes, we can reduce this code to the following:  void IntList :: pushBack(int n){\n    Node* loop = 0;\n    for(loop = head; loop->next != 0; loop = loop->next){}\n    loop->next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head->next == 0){\n        return; //list is empty\n    }\n    else{\n        Node* temp = head->next;\n        head->next = temp->next;\n        delete temp;\n    }\n}  Notice how in both functions, the  if(head == 0)  is no longer a case we have to check for\n(since head will never be 0). This helps simplify the code and handle common edge cases.  Other functions must of course also be changed such as the print function, but the overall\ncomplexity of the code decreases. The contents of the dummy node don't matter as they shouldn't\never be seen.",
            "title": "Dummy Nodes"
        },
        {
            "location": "/lec_week_02/#exercise-1-fibonacci-exercise",
            "text": "Fn = Fn-1 + Fn-2  F0 = 0, F1 = 1  Write a program that will calculate a specified fibonacci number using the  std::list data \nstructure. Think about how to use a list to store values of the formula above.   Input:    integer n  Output:   nth Fibonacci number   Example:   Which Fibonacci number to calculate:  10  10th Fibonacci number:  55",
            "title": "Exercise 1: Fibonacci Exercise"
        },
        {
            "location": "/lec_week_02/#exercise-2-palindrome-exercise",
            "text": "Write a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.   Input:    string input  Output:   result of the palindrome test   Example:   Enter a word to test for palindrome:  tacocats  tacocats  is not a palindrome.   Key functions to incorporate: back(), pop_back()",
            "title": "Exercise 2: Palindrome Exercise"
        },
        {
            "location": "/lec_week_02/#exercise-3-animation",
            "text": "We've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!  At the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into  cout !  Note, since we're giving you a precompiled file, you're going to have to use C9 for this exercise",
            "title": "Exercise 3: Animation!"
        },
        {
            "location": "/lec_week_02/#how-to-get-the-code",
            "text": "In your C9 terminal, run the following in the directory where you want the code  git clone https://github.com/scohe001/Animations  You'll notice you now have a  main , an  Animator  class and a couple animation files (don't look at them yet, it'll ruin the surprise! * ).  We've already completely implemented the  Animator  class for you and compiled it, so all you'll have to do is finish off the  main  skeleton! The details for doing so are in the comments, so don't just delete them!",
            "title": "How to get the code"
        },
        {
            "location": "/lec_week_02/#compiling",
            "text": "Since we're using C++11 features and threading, you'll have to compile with the following:  g++ -std=c++11 -pthread -Wall main.cpp animation.o  After you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!  Once you have all of the animations working, delete  animation.o  and use the skeleton  animation.cpp  we've given you to complete the  Animation  class! Recompiling the  Animation  class should look like the following:  g++ -std=c++11 -pthread -c animation.cpp  *  Since you're all CS majors I'm sure the lot of you have already looked at them >.>",
            "title": "Compiling"
        },
        {
            "location": "/lab_week_02/",
            "text": "Lab 2: The Standard Template Library\n\n\nThe Standard Template Library, or the \nSTL\n for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.\n\n\nSome of these algorithms range from simple algorithms such\nas \nstd::swap\n to the more complex \nstd::sort\n.\n\n\nThe motivation for learning and mastering the STL is to write \ncode that is clear and concise\n.\n\n\nIterators\n\n\nProbably the most important and inescapable concept in the\nSTL is the types we call iterators.\n\n\nIterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).\n\n\nThe easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).\n\n\n\"Enough talk, show me the code!\"\n Here's how you can iterate through a vector using iterators!\n\n\nvector<int> vec {1, 2, 3};\nvector<int>::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout << *vec_iterator << ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \"1 2 3 \"\n\n\n\n\nNote the \nvec.begin()\n and \nvec.end()\n calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type \nvector<int>::iterator\n.\n\n\nvec.begin()\n returns an iterator to beginning of \nvec\n. However, \nvec.end()\n returns an iterator to the element \none past\n the last element.\n\n\nThis is pictured below (image from en.cppreference.com)\n\n\n\nA lot of algorithms in the STL, including \nstd::sort\n\nexpect iterators as arguments. \n(and usually specific types of iterators)\n\n\nOne of the function prototypes for \nstd::sort\n looks\nsomething like this:\n\n\ntemplate<typename RandomIt>\nvoid sort(Iterator first, Iterator last);\n\n\n\n\nAs long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\n    vector<int> vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout << *vec_iter << ' ';\n    }\n}\n\n\n\n\n`\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nThat's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!\n\n\nFunction Objects\n\n\nBack in CS12, you learned that you can \noverload\n\nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the\n\n+\n operator may look like this (assume the \ngcd\n function is defined):\n\n\nbool operator+(const Rational & other) {\n    int new_denom = gcd(this -> denom, other.denom);\n    int this_multipler = new_denom/(this -> denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -> numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}\n\n\n\n\nYou can also overload the function call operator by\ndefining a function with the function name \noperator()\n.\n\n\ne.g.\n\n\n#include <iostream>\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout << count.get_count() << endl;\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nOverloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include \nstd::sort\n\nand \nstd::copy_if\n. The most common types of\nfunction objects that these algorithms accept as input are\n\ncomparison function objects\n which return\ntrue if the first argument is \nconsidered\n less than the second and\na unary predicate which returns true if it satisfies some condition.\n\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <list>\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int & a, const int & b ) const {\n            return a > b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int & x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector<int> from_vector {1, 2, 3, 4};\n    list<int> to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout << elem << ' ';\n    }\n    cout << endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout << elem << ' ';\n    }\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nExercise 1 - Reverse Polish Notation\n\n\nReverse Polish notation (RPN)\n is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.\n\n\nIn reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.\n\n\nAn advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".\n\n\nYour task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.\n\n\nExample:\n\n\n\n\nInput: 5 1 2 + 4 * + 3 -\n\n\nOutput: 14\n\n\n\n\nFor this exercise, implement the calculator using your choice of list.\n\n\nCool References\n\n\nStandard Template Library Video Series by Stephan T. Lavaej at Microsoft",
            "title": "Lab Week 2"
        },
        {
            "location": "/lab_week_02/#lab-2-the-standard-template-library",
            "text": "The Standard Template Library, or the  STL  for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.  Some of these algorithms range from simple algorithms such\nas  std::swap  to the more complex  std::sort .  The motivation for learning and mastering the STL is to write  code that is clear and concise .",
            "title": "Lab 2: The Standard Template Library"
        },
        {
            "location": "/lab_week_02/#iterators",
            "text": "Probably the most important and inescapable concept in the\nSTL is the types we call iterators.  Iterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).  The easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).  \"Enough talk, show me the code!\"  Here's how you can iterate through a vector using iterators!  vector<int> vec {1, 2, 3};\nvector<int>::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout << *vec_iterator << ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \"1 2 3 \"  Note the  vec.begin()  and  vec.end()  calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type  vector<int>::iterator .  vec.begin()  returns an iterator to beginning of  vec . However,  vec.end()  returns an iterator to the element  one past  the last element.  This is pictured below (image from en.cppreference.com)  A lot of algorithms in the STL, including  std::sort \nexpect iterators as arguments.  (and usually specific types of iterators)  One of the function prototypes for  std::sort  looks\nsomething like this:  template<typename RandomIt>\nvoid sort(Iterator first, Iterator last);  As long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).  #include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\n    vector<int> vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout << *vec_iter << ' ';\n    }\n}  ` Try it yourself - before compiling guess what the above program outputs.  That's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!",
            "title": "Iterators"
        },
        {
            "location": "/lab_week_02/#function-objects",
            "text": "Back in CS12, you learned that you can  overload \nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the +  operator may look like this (assume the  gcd  function is defined):  bool operator+(const Rational & other) {\n    int new_denom = gcd(this -> denom, other.denom);\n    int this_multipler = new_denom/(this -> denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -> numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}  You can also overload the function call operator by\ndefining a function with the function name  operator() .  e.g.  #include <iostream>\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout << count.get_count() << endl;\n}  Try it yourself - before compiling guess what the above program outputs.  Overloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include  std::sort \nand  std::copy_if . The most common types of\nfunction objects that these algorithms accept as input are comparison function objects  which return\ntrue if the first argument is  considered  less than the second and\na unary predicate which returns true if it satisfies some condition.  #include <iostream>\n#include <algorithm>\n#include <vector>\n#include <list>\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int & a, const int & b ) const {\n            return a > b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int & x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector<int> from_vector {1, 2, 3, 4};\n    list<int> to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout << elem << ' ';\n    }\n    cout << endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout << elem << ' ';\n    }\n}  Try it yourself - before compiling guess what the above program outputs.",
            "title": "Function Objects"
        },
        {
            "location": "/lab_week_02/#exercise-1-reverse-polish-notation",
            "text": "Reverse Polish notation (RPN)  is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.  In reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.  An advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".  Your task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.  Example:   Input: 5 1 2 + 4 * + 3 -  Output: 14   For this exercise, implement the calculator using your choice of list.",
            "title": "Exercise 1 - Reverse Polish Notation"
        },
        {
            "location": "/lab_week_02/#cool-references",
            "text": "Standard Template Library Video Series by Stephan T. Lavaej at Microsoft",
            "title": "Cool References"
        },
        {
            "location": "/lec_week_03/",
            "text": "Big-O Time Complexity\n\n\nFor the following functions give the nearest Big-O time complexity.\n\n\nProblem 1\n\n\nint f1(const std::vector<int>& v) {\n    int result = 0;\n    for (int i = 0; i < v.size(); ++i) {\n        for (int j = v.size(); j >= 0; j -= 2) {\n            result += v.at(i) * j;\n        }\n    }\n    return result;\n}\n\n\n\n\nProblem 2\n\n\nvoid f2(std::list<int>& l, int n) {\n    for (int i = 0; i < n; ++i) {\n        l.remove(i);\n    }\n}\n\n\n\n\nProblem 3\n\n\nvoid f3(int n, int m, int r) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = m; m > 0; m /= 2) {\n            while (r > 0) {\n                std::cout << r << std::endl;\n                --r;\n            }\n        }\n    }\n}\n\n\n\n\nProblem 4\n\n\nvoid f4(std::vector<int>& v) {\n    for (std::vector<int>::iterator itr = v.begin(); itr != v.end(); ++itr) {\n        std::random_shuffle(itr, v.end());\n        for (auto itr2 = v.begin(); itr2 != v.end(); ++itr2) {\n            std::cout << *itr2 << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::sort(v.begin(), v.end());\n}\n\n\n\n\nProblem 5\n\n\nvoid f5(std::stack<int>& s) {\n    if (s.empty()) return;\n    std::stack<int> temp;\n    int min;\n    for (int i = 0; i < s.size(); ++i) {\n        min = s.top();\n        s.pop();\n        for(int j = i; j < s.size(); ++j) {\n            if (s.top() < min) {\n                temp.push(min);\n                min = s.top();\n            }\n            else temp.push(s.top());\n            s.pop();\n        }\n        s.push(min);\n        while(!temp.empty()) {\n            s.push(temp.top());\n            temp.pop();\n        }\n    }\n}\n\n\n\n\nProblem 6\n\n\nFor this problem just give the Big-O time complexity for \nf6\n\n\nBonus: What is the Big-O space complexity for \nf6\n?\n\n\n\n\nvoid f6(std::queue<int>& q) {\n    if (q.size() <= 1) return;\n    std::queue<int> left;\n    std::queue<int> right;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        left.push(q.front());\n        q.pop();\n    }\n    while(!q.empty()) {\n        right.push(q.front());\n        q.pop();\n    }\n    f6(left);\n    f6(right);\n    q = f7(left, right);\n}\n\nstd::queue<int> f7(std::queue<int>& left, std::queue<int>& right){\n    std::queue<int> result;\n    while(!left.empty() && !right.empty()) {\n        if (left.front() > right.front()) {\n            resulti.push(right.front());\n            right.pop();\n        }\n        else {\n            result.push(left.front());\n            left.pop();\n        }\n    }\n    while(!left.empty()) {\n        result.push(left.front());\n        left.pop();\n    }\n    while(!right.empty()) {\n        result.push(right.front());\n        right.pop();\n    }\n    return result;\n}",
            "title": "Big-O Analysis"
        },
        {
            "location": "/lec_week_03/#big-o-time-complexity",
            "text": "For the following functions give the nearest Big-O time complexity.",
            "title": "Big-O Time Complexity"
        },
        {
            "location": "/lec_week_03/#problem-1",
            "text": "int f1(const std::vector<int>& v) {\n    int result = 0;\n    for (int i = 0; i < v.size(); ++i) {\n        for (int j = v.size(); j >= 0; j -= 2) {\n            result += v.at(i) * j;\n        }\n    }\n    return result;\n}",
            "title": "Problem 1"
        },
        {
            "location": "/lec_week_03/#problem-2",
            "text": "void f2(std::list<int>& l, int n) {\n    for (int i = 0; i < n; ++i) {\n        l.remove(i);\n    }\n}",
            "title": "Problem 2"
        },
        {
            "location": "/lec_week_03/#problem-3",
            "text": "void f3(int n, int m, int r) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = m; m > 0; m /= 2) {\n            while (r > 0) {\n                std::cout << r << std::endl;\n                --r;\n            }\n        }\n    }\n}",
            "title": "Problem 3"
        },
        {
            "location": "/lec_week_03/#problem-4",
            "text": "void f4(std::vector<int>& v) {\n    for (std::vector<int>::iterator itr = v.begin(); itr != v.end(); ++itr) {\n        std::random_shuffle(itr, v.end());\n        for (auto itr2 = v.begin(); itr2 != v.end(); ++itr2) {\n            std::cout << *itr2 << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::sort(v.begin(), v.end());\n}",
            "title": "Problem 4"
        },
        {
            "location": "/lec_week_03/#problem-5",
            "text": "void f5(std::stack<int>& s) {\n    if (s.empty()) return;\n    std::stack<int> temp;\n    int min;\n    for (int i = 0; i < s.size(); ++i) {\n        min = s.top();\n        s.pop();\n        for(int j = i; j < s.size(); ++j) {\n            if (s.top() < min) {\n                temp.push(min);\n                min = s.top();\n            }\n            else temp.push(s.top());\n            s.pop();\n        }\n        s.push(min);\n        while(!temp.empty()) {\n            s.push(temp.top());\n            temp.pop();\n        }\n    }\n}",
            "title": "Problem 5"
        },
        {
            "location": "/lec_week_03/#problem-6",
            "text": "For this problem just give the Big-O time complexity for  f6  Bonus: What is the Big-O space complexity for  f6 ?  \n\nvoid f6(std::queue<int>& q) {\n    if (q.size() <= 1) return;\n    std::queue<int> left;\n    std::queue<int> right;\n    for (int i = 0; i < q.size() / 2; ++i) {\n        left.push(q.front());\n        q.pop();\n    }\n    while(!q.empty()) {\n        right.push(q.front());\n        q.pop();\n    }\n    f6(left);\n    f6(right);\n    q = f7(left, right);\n}\n\nstd::queue<int> f7(std::queue<int>& left, std::queue<int>& right){\n    std::queue<int> result;\n    while(!left.empty() && !right.empty()) {\n        if (left.front() > right.front()) {\n            resulti.push(right.front());\n            right.pop();\n        }\n        else {\n            result.push(left.front());\n            left.pop();\n        }\n    }\n    while(!left.empty()) {\n        result.push(left.front());\n        left.pop();\n    }\n    while(!right.empty()) {\n        result.push(right.front());\n        right.pop();\n    }\n    return result;\n}",
            "title": "Problem 6"
        },
        {
            "location": "/lec_week_03_pt2/",
            "text": "Exceptions\n\n\nAn \nexception\n is a circumstance that a program was not designed to handle. They are useful for when you need your program to detect and handle errors that may occur during program execution.\n\n\nHere's an example of code without error checking:\n\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout << \"Enter your height (in inches): \";\n  cin >> height;\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n\n  return 0;\n}\n\n\n\n\nNow let's do some test with some edge cases and see what the program outputs:\n\n\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nYour height is equivalant to: -4 feet -6 inches!    //<------- Oh no!\n\n\n\n\nSo what most of you have been doing to avoid this error is a good implementation of branches!\n\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout << \"Enter your height (in inches): \";\n  cin >> height;\n\n  //If the height is less than 0, output error message and return\n  if(height < 0)\n  {\n    cout << \"Error! Invalid height!\" << endl;\n    return 0;\n  }\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n\n  return 0;\n}\n\n\n\n\nNow let's test this new code with the same input:\n\n\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!                //<----- Much better~\n\n\n\n\nA more sophisticated way of handling these errors are \nexception-handling constructs\n. Using these constructs allows us to keep error-checking code separate from our main code.\n\n\n//Exception handling construct\n\n//... means normal code\n//...\ntry\n{\n  //...\n\n  //If error detected\n  throw objectOfExceptionType;\n\n  //...\n\n}\ncatch (exceptionType execptionObject)\n{\n  //Handle exception, e.g., print message\n}\n//...\n\n\n\n\nException constructs have three parts:\n\n\n\n\nA \ntry\n block surrounds normal code, which is exited immediately if a throw statement executes.\n\n\nA \nthrow\n statement appears within a try block; if reached, execution jumps immediately to the end of the try block. The code is written so only error situations lead to reaching a throw. The throw statement provides an object of a particular type, such as an object of type \"runtime_error\", which is a class defined in the \nstdexcept\n library. The statement is said to throw an exception of the particular type. A throw statement's syntax is similar to a return statement.\n\n\nA \ncatch\n clause immediately follows a try block; if the catch was reached due to an exception thrown of the catch clause's parameter type, the clause executes. The clause is said to catch the thrown exception. A catch block is called a \nhandler\n because it handles an exception.\n\n\n\n\nHere's the earlier program using exception-handling constructs. Notice that the normal code flow is not obscured by error-checking/handling if-else statements.\n\n\n#include <iostream>\n#include <stdexcept>  //Exception class\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n\n  try\n  {\n    //Get input\n    cout << \"Enter your height (in inches): \";\n    cin >> height;\n\n    if(height < 0)\n    {\n      throw runtime_error(\"Error! Invalid height!\");\n    }\n\n    //Return converted height input\n    int feet = height / 12;\n    int inches = height % 12;\n    cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n  }\n  catch(runtime_error &excpt)\n  {\n    //Print error message passed by throw statement\n    cout << excpt.what() << endl;\n  }\n\n  return 0;\n}\n\n\n\n\nOutput:\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!              \n\n\n\n\n\nExceptions with functions\n\n\nNow you may be thinking, why even use exceptions?\n\n\n\n\nWell, the power of exceptions becomes clearer when used within a function. If an exception is thrown within a function and not caught within that function, then the function is immediately exited and the calling function is checked for a handler, and so on up the function call hierarchy.\n\n\nHere's an expanded program where we utilize functions with execptions:\n\n\n#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid getHeight(int & feet, int & inches)\n{\n   int height = 0; // User defined weight\n\n   // Get user data\n   cout << \"Enter height (in inches): \";\n   cin >> height;\n\n   // Error checking, non-negative weight\n   if (height < 0)\n   {\n      throw runtime_error(\"Error! Invalid height!\");\n   }\n\n   //Calculate conversions\n   feet = height / 12;\n   inches = height % 12;\n\n   return;\n}\n\nvoid getWeight(double & kilograms)\n{\n  int weight; // User defined weight\n\n  //Get user Data\n  cout << \"Enter weight (in pounds): \";\n  cin >> weight;\n\n  if (weight < 0)\n  {\n      throw runtime_error(\"Error! Invalid weight!\");\n  }\n\n  //Calculate conversions\n  kilograms = weight / 0.453592;\n\n  return;\n}\n\nint main()\n{\n  int feet, inches = 0;\n  double kilograms = 0;\n\n  try\n  {\n      //Get user data\n      getHeight(feet, inches);\n      getWeight(kilograms);\n\n      cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl\n           << \"Your weight is equivalant to: \" << kilograms << \" kilograms!\" << endl;\n  }\n  catch (runtime_error & excpt)\n  {\n      cout << excpt.what() << endl;\n      cout << \"Cannot compute info.\" << endl;\n  }\n\n  return 0;\n}\n\n\n\n\nIn the code above we added a part to take in the user's weight. We then separated the user input into two different functions, each throwing their own exception. Now let's look at the code output:\n\n\n//Valid input\nEnter height (in inches): 75\nEnter weight (in pounds): 150\nYour height is equivalant to: 6 feet 3 inches!\nYour weight is equivalant to: 330.694 kilograms!\n\n//Invalid height\nEnter height (in inches): -55\nError! Invalid height!\nCannot compute info.\n\n//Invalid weight\nEnter height (in inches): 75\nEnter weight (in pounds): -100\nError! Invalid weight!\nCannot compute info.\n\n\n\n\nMultiple Exceptions\n\n\n\n\n\n\nBut wait....there's more!...\n\n\n\n\n\n\nMultiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.\n\n\nException handling using multiple handlers:\n\n...\ntry\n{\n  ...\n  throw objectOfExceptionType1;\n  ...\n  throw objectOfExceptionType2;\n  ...\n  throw objectOfExceptionType3;\n  ...\n}\ncatch (excptType1 & exceptObj1)\n{\n  //Handle type1\n}\ncatch (excptType2 & exceptObj2)\n{\n  //Handle type2\n}\ncatch (...)\n{\n  //Default handler. Catches all other objects (e.g. type3)\n}\n...//Execution continues\n\n\n\n\nOne thing to note is that if exceptObj2 is a subclass of exceptObj1, then objectOfExceptionType2 will always be caught by the first catch exception. A \ncommon error\n is to place a catch block intended to handle exceptions of a base class before catch blocks intended to handle exceptions of a derived class, preventing the latter from ever executing.\n\n\nHere's an example of using multiple handles. Note that exceptions can also be nested!\n\n\n#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nint main()\n{\n  vector<int> v(10);\n  int input = 0;\n  int secondInput = 0;\n  int thirdInput = 0;\n\n  try\n  {\n      //Try getting a positive number. If a negative number is entered,\n      //it will throw an exception but still continue to the code after the catch\n      try\n      {\n        cout << \"Enter a positive number: \";\n        cin >> input;\n\n        if(input < 0)\n        {\n          throw logic_error(\"input variable is invalid!\");\n        }\n      }\n      catch (logic_error & excpt)\n      {\n          cout << \"Logic error!: \" << excpt.what() << endl;\n      }\n\n      //Get negative number from user\n      cout << \"Enter a negative number: \";\n      cin >> secondInput;\n\n      if(secondInput > 0)\n      {\n        throw runtime_error(\"Second input is not a negative number!\");\n      }\n\n      //Get 0 from user\n      cout << \"Enter 0: \";\n      cin >> thirdInput;\n\n      if(thirdInput != 0)\n      {\n        throw -1;\n      }\n\n      //Attempt to access an out-of-range index\n      cout << v.at(20) << endl; //This will throw an out-of-range exception\n\n  }\n  catch (out_of_range & excpt)\n  {\n      cout << \"Out of range error!: \" << excpt.what() << endl;\n  }\n  catch (runtime_error & excpt)\n  {\n      cout << \"Runtime error!: \" << excpt.what() << endl;\n  }\n  catch (...)\n  {\n      cout << \"Non-zero error!: User did not input a 0!\" << endl;\n  }\n\n  return 0;\n}\n\n\n\n\nOutput:\n//Valid inputs\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid first input\nEnter a positive number: -1\nLogic error!: input variable is invalid!    //<---- Note that the program still continues\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid second input\nEnter a positive number: 1\nEnter a negative number: 1\nRuntime error!: Second input is not a negative number!\n\n//Invalid third input\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 9999\nNon-zero error!: User did not input a 0!",
            "title": "Exceptions"
        },
        {
            "location": "/lec_week_03_pt2/#exceptions",
            "text": "An  exception  is a circumstance that a program was not designed to handle. They are useful for when you need your program to detect and handle errors that may occur during program execution.  Here's an example of code without error checking:  #include <iostream>\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout << \"Enter your height (in inches): \";\n  cin >> height;\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n\n  return 0;\n}  Now let's do some test with some edge cases and see what the program outputs:  //Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nYour height is equivalant to: -4 feet -6 inches!    //<------- Oh no!  So what most of you have been doing to avoid this error is a good implementation of branches!  #include <iostream>\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n  cout << \"Enter your height (in inches): \";\n  cin >> height;\n\n  //If the height is less than 0, output error message and return\n  if(height < 0)\n  {\n    cout << \"Error! Invalid height!\" << endl;\n    return 0;\n  }\n\n  //Return converted height input\n  int feet = height / 12;\n  int inches = height % 12;\n  cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n\n  return 0;\n}  Now let's test this new code with the same input:  //Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!                //<----- Much better~  A more sophisticated way of handling these errors are  exception-handling constructs . Using these constructs allows us to keep error-checking code separate from our main code.  //Exception handling construct\n\n//... means normal code\n//...\ntry\n{\n  //...\n\n  //If error detected\n  throw objectOfExceptionType;\n\n  //...\n\n}\ncatch (exceptionType execptionObject)\n{\n  //Handle exception, e.g., print message\n}\n//...  Exception constructs have three parts:   A  try  block surrounds normal code, which is exited immediately if a throw statement executes.  A  throw  statement appears within a try block; if reached, execution jumps immediately to the end of the try block. The code is written so only error situations lead to reaching a throw. The throw statement provides an object of a particular type, such as an object of type \"runtime_error\", which is a class defined in the  stdexcept  library. The statement is said to throw an exception of the particular type. A throw statement's syntax is similar to a return statement.  A  catch  clause immediately follows a try block; if the catch was reached due to an exception thrown of the catch clause's parameter type, the clause executes. The clause is said to catch the thrown exception. A catch block is called a  handler  because it handles an exception.   Here's the earlier program using exception-handling constructs. Notice that the normal code flow is not obscured by error-checking/handling if-else statements.  #include <iostream>\n#include <stdexcept>  //Exception class\nusing namespace std;\n\nint main()\n{\n  //Get height input\n  int height = 0;\n\n  try\n  {\n    //Get input\n    cout << \"Enter your height (in inches): \";\n    cin >> height;\n\n    if(height < 0)\n    {\n      throw runtime_error(\"Error! Invalid height!\");\n    }\n\n    //Return converted height input\n    int feet = height / 12;\n    int inches = height % 12;\n    cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl;\n  }\n  catch(runtime_error &excpt)\n  {\n    //Print error message passed by throw statement\n    cout << excpt.what() << endl;\n  }\n\n  return 0;\n}  Output:\n//Normal Input\nEnter your height (in inches): 75\nYour height is equivalant to: 6 feet 3 inches!\n\n//Zero Input\nEnter your height (in inches): 0\nYour height is equivalant to: 0 feet 0 inches!\n\n//Negative Input\nEnter your height (in inches): -54\nError! Invalid height!",
            "title": "Exceptions"
        },
        {
            "location": "/lec_week_03_pt2/#exceptions-with-functions",
            "text": "Now you may be thinking, why even use exceptions?   Well, the power of exceptions becomes clearer when used within a function. If an exception is thrown within a function and not caught within that function, then the function is immediately exited and the calling function is checked for a handler, and so on up the function call hierarchy.  Here's an expanded program where we utilize functions with execptions:  #include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid getHeight(int & feet, int & inches)\n{\n   int height = 0; // User defined weight\n\n   // Get user data\n   cout << \"Enter height (in inches): \";\n   cin >> height;\n\n   // Error checking, non-negative weight\n   if (height < 0)\n   {\n      throw runtime_error(\"Error! Invalid height!\");\n   }\n\n   //Calculate conversions\n   feet = height / 12;\n   inches = height % 12;\n\n   return;\n}\n\nvoid getWeight(double & kilograms)\n{\n  int weight; // User defined weight\n\n  //Get user Data\n  cout << \"Enter weight (in pounds): \";\n  cin >> weight;\n\n  if (weight < 0)\n  {\n      throw runtime_error(\"Error! Invalid weight!\");\n  }\n\n  //Calculate conversions\n  kilograms = weight / 0.453592;\n\n  return;\n}\n\nint main()\n{\n  int feet, inches = 0;\n  double kilograms = 0;\n\n  try\n  {\n      //Get user data\n      getHeight(feet, inches);\n      getWeight(kilograms);\n\n      cout << \"Your height is equivalant to: \" << feet << \" feet \" << inches << \" inches!\" << endl\n           << \"Your weight is equivalant to: \" << kilograms << \" kilograms!\" << endl;\n  }\n  catch (runtime_error & excpt)\n  {\n      cout << excpt.what() << endl;\n      cout << \"Cannot compute info.\" << endl;\n  }\n\n  return 0;\n}  In the code above we added a part to take in the user's weight. We then separated the user input into two different functions, each throwing their own exception. Now let's look at the code output:  //Valid input\nEnter height (in inches): 75\nEnter weight (in pounds): 150\nYour height is equivalant to: 6 feet 3 inches!\nYour weight is equivalant to: 330.694 kilograms!\n\n//Invalid height\nEnter height (in inches): -55\nError! Invalid height!\nCannot compute info.\n\n//Invalid weight\nEnter height (in inches): 75\nEnter weight (in pounds): -100\nError! Invalid weight!\nCannot compute info.",
            "title": "Exceptions with functions"
        },
        {
            "location": "/lec_week_03_pt2/#multiple-exceptions",
            "text": "But wait....there's more!...    Multiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.  Exception handling using multiple handlers:\n\n...\ntry\n{\n  ...\n  throw objectOfExceptionType1;\n  ...\n  throw objectOfExceptionType2;\n  ...\n  throw objectOfExceptionType3;\n  ...\n}\ncatch (excptType1 & exceptObj1)\n{\n  //Handle type1\n}\ncatch (excptType2 & exceptObj2)\n{\n  //Handle type2\n}\ncatch (...)\n{\n  //Default handler. Catches all other objects (e.g. type3)\n}\n...//Execution continues  One thing to note is that if exceptObj2 is a subclass of exceptObj1, then objectOfExceptionType2 will always be caught by the first catch exception. A  common error  is to place a catch block intended to handle exceptions of a base class before catch blocks intended to handle exceptions of a derived class, preventing the latter from ever executing.  Here's an example of using multiple handles. Note that exceptions can also be nested!  #include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nint main()\n{\n  vector<int> v(10);\n  int input = 0;\n  int secondInput = 0;\n  int thirdInput = 0;\n\n  try\n  {\n      //Try getting a positive number. If a negative number is entered,\n      //it will throw an exception but still continue to the code after the catch\n      try\n      {\n        cout << \"Enter a positive number: \";\n        cin >> input;\n\n        if(input < 0)\n        {\n          throw logic_error(\"input variable is invalid!\");\n        }\n      }\n      catch (logic_error & excpt)\n      {\n          cout << \"Logic error!: \" << excpt.what() << endl;\n      }\n\n      //Get negative number from user\n      cout << \"Enter a negative number: \";\n      cin >> secondInput;\n\n      if(secondInput > 0)\n      {\n        throw runtime_error(\"Second input is not a negative number!\");\n      }\n\n      //Get 0 from user\n      cout << \"Enter 0: \";\n      cin >> thirdInput;\n\n      if(thirdInput != 0)\n      {\n        throw -1;\n      }\n\n      //Attempt to access an out-of-range index\n      cout << v.at(20) << endl; //This will throw an out-of-range exception\n\n  }\n  catch (out_of_range & excpt)\n  {\n      cout << \"Out of range error!: \" << excpt.what() << endl;\n  }\n  catch (runtime_error & excpt)\n  {\n      cout << \"Runtime error!: \" << excpt.what() << endl;\n  }\n  catch (...)\n  {\n      cout << \"Non-zero error!: User did not input a 0!\" << endl;\n  }\n\n  return 0;\n}  Output:\n//Valid inputs\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid first input\nEnter a positive number: -1\nLogic error!: input variable is invalid!    //<---- Note that the program still continues\nEnter a negative number: -1\nEnter 0: 0\nOut of range error!: vector::_M_range_check\n\n//Invalid second input\nEnter a positive number: 1\nEnter a negative number: 1\nRuntime error!: Second input is not a negative number!\n\n//Invalid third input\nEnter a positive number: 1\nEnter a negative number: -1\nEnter 0: 9999\nNon-zero error!: User did not input a 0!",
            "title": "Multiple Exceptions"
        },
        {
            "location": "/lec_week_03_pt3/",
            "text": "Templates\n\n\nYou may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node.\n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode * next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};\n\n\n\n\nThat's all fine and dandy, but if instead want a \nDoubleList\n or a\n\nStringList\n, then we are in trouble.\n\n\nA common first instinct is to copy-and-paste code manually\nand change the types where needed. But even expert programmers\nstart to \nmake mistakes\n\ncopy and pasting.\n\n\nIntroducing templates!\n\n\nThe solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.\n\n\nIn fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.\n\n\nTo create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".\n\n\nvector<int> numbers; // creates a vector of integers\nvector<string> words; // creates a vector of strings\n\n\n\n\nTo create a new class template, before our class declaration we use the keyword \ntemplate\n followed by a type parameter inside \"angle-brackets\"\ne.g. \ntemplate<typename T>\n. The keyword \ntypename\n tells the compiler\nthat \nT\n is a placeholder for an actual type.\n\n\nNote: \nT\n is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is \nContainer\n\n\nLet's say, we want to create a templated version of our Node and List.\n\n\nIntNode\n becomes:\n\n\ntemplate<typename T>\nstruct Node {\n   T val;\n   Node<T> * next;\n};\n\n\n\n\nand \nIntLinkedList\n becomes:\n\n\ntemplate<typename T>\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node<T> * head;\n};\n\n\n\n\nTo create a \nLinkedList\n of doubles, we declare the list as so:\n\n\nLinkedList<double> list;\n\n\n\n\nIn order to template functions and method, we do something similar.\n\n\nFor example, if we want to define the templated LinkedList's\n\npush_front\n method:\n\n\ntemplate<typename T>\nLinkedList<T>::push_front(T val) {\n    Node * new_node = new Node<T>();\n    new_node -> val = val;\n\n    Node * old_head = this -> head;\n    new_node -> next = old_head;\n    this -> head = new_node;\n}\n\n\n\n\nFor more info on templates check out \nthis FAQ\n!\n\n\nExercises\n\n\nImplement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!\n\n\nPro-Tip: before implementing the class as a class template, \ntypedef\n the type \nT\n as an integer and replace type with \nT\n as needed.\n\ne.g.\n\n\ntypedef int T; // give the int an alias which is T\nT my_int = 42;\n\n\n\n\nThis give you much nicer error messages and makes it easier to debug.\n\n\nExample Usage, should implement at least the following methods:\n\n\nMyVector<string> vec;\nvec.push_back(\"CS14\");\nvec.push_back(\"World\");\nvec.insert(\"Hello\", 0);\ncout << vec.front() << endl; // \"Hello\"\ncout << vec.back() << endl; // \"World\"\nvec.pop_back();\ncout << vec.back() << endl; // \"CS14\"\nvec.pop_back();\ncout << vec.back() << endl; // \"Hello\"\n\nMyVector<int> another_vec;\nanother_vec.push_back(42);\n\n\n\n\nStretch-goal exercise:\n\n\nRewrite your IntList as a class template!",
            "title": "Templates"
        },
        {
            "location": "/lec_week_03_pt3/#templates",
            "text": "You may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".  In order to implement a Linked List, you must define the structure\nfor an individual node.  For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode * next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};  That's all fine and dandy, but if instead want a  DoubleList  or a StringList , then we are in trouble.  A common first instinct is to copy-and-paste code manually\nand change the types where needed. But even expert programmers\nstart to  make mistakes \ncopy and pasting.",
            "title": "Templates"
        },
        {
            "location": "/lec_week_03_pt3/#introducing-templates",
            "text": "The solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.  In fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.  To create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".  vector<int> numbers; // creates a vector of integers\nvector<string> words; // creates a vector of strings  To create a new class template, before our class declaration we use the keyword  template  followed by a type parameter inside \"angle-brackets\"\ne.g.  template<typename T> . The keyword  typename  tells the compiler\nthat  T  is a placeholder for an actual type.  Note:  T  is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is  Container  Let's say, we want to create a templated version of our Node and List.  IntNode  becomes:  template<typename T>\nstruct Node {\n   T val;\n   Node<T> * next;\n};  and  IntLinkedList  becomes:  template<typename T>\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node<T> * head;\n};  To create a  LinkedList  of doubles, we declare the list as so:  LinkedList<double> list;  In order to template functions and method, we do something similar.  For example, if we want to define the templated LinkedList's push_front  method:  template<typename T>\nLinkedList<T>::push_front(T val) {\n    Node * new_node = new Node<T>();\n    new_node -> val = val;\n\n    Node * old_head = this -> head;\n    new_node -> next = old_head;\n    this -> head = new_node;\n}  For more info on templates check out  this FAQ !",
            "title": "Introducing templates!"
        },
        {
            "location": "/lec_week_03_pt3/#exercises",
            "text": "Implement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!  Pro-Tip: before implementing the class as a class template,  typedef  the type  T  as an integer and replace type with  T  as needed. \ne.g.  typedef int T; // give the int an alias which is T\nT my_int = 42;  This give you much nicer error messages and makes it easier to debug.  Example Usage, should implement at least the following methods:  MyVector<string> vec;\nvec.push_back(\"CS14\");\nvec.push_back(\"World\");\nvec.insert(\"Hello\", 0);\ncout << vec.front() << endl; // \"Hello\"\ncout << vec.back() << endl; // \"World\"\nvec.pop_back();\ncout << vec.back() << endl; // \"CS14\"\nvec.pop_back();\ncout << vec.back() << endl; // \"Hello\"\n\nMyVector<int> another_vec;\nanother_vec.push_back(42);",
            "title": "Exercises"
        },
        {
            "location": "/lec_week_03_pt3/#stretch-goal-exercise",
            "text": "Rewrite your IntList as a class template!",
            "title": "Stretch-goal exercise:"
        },
        {
            "location": "/lab_week_03/",
            "text": "Lab 3: Templates and Exceptions\n\n\nExercise 1- Circular int Queue\n\n\nFor this exercise you will be implementing an array-based queue with circular functionality like the one in Professor Miller's \nslides\n. Implement the functionality in a class called 'Queue' and include the following functions:\n\n\nQueue();\nvoid enqueue(int n);\nvoid dequeue();\nint getFirst();\nint getLast();\n};\n\n\n\n\nWhen creating the underlying array, feel free to set a max size of the array like so:\n\nint arr[10]; // Max Queue size\n\n\nExercise 1.1. Exceptions\n\n\nUsing what you have learned about exceptions, throw an exception when the user tries to call the \nenqueue(int n);\n\nfunction when the queue has hit its capacity (max size) or when the user tries to call \ngetFirst();\n or \ngetLast();\n\non an empty queue.\n\n\nExercise 2 - Iterators\n\n\nDefinition:\n An iterator is any object that, pointing to some element in a range\nof elements (such as an array or a container), \nhas the ability to iterate through the elements of that range using a set of operators (with at least the \nincrement \n++\n and dereference \n*\n operators).\n\n\nThe most obvious form of iterator is a pointer: A pointer can \npoint to elements in an array, and can iterate through them using the increment operator \n++\n. But other kinds \nof iterators are possible. For example, each container type (such as a list) has a specific iterator type designed \nto iterate through its elements. Notice that while a pointer is a form of iterator, not all iterators have the same \nfunctionality of pointers.\n\n\nWe will learn about the built-in iterator class for the C++ list class. You can think of this iterator as a super-powered\n\nNode* ptr\n which will automatically switch to the next node if you call \nptr++\n. You can even iterate backwards using \nptr--;\n\nWow!\n\n\nLet's say you have a list called \nmyList\n.\nYou can call public member functions: \nmyList.begin()\n and \nmyList.end()\n.\nmyList.begin()\n will return an iterator that points to the \nlist's \nHEAD->next\n. \nmyList.end();\n returns an iterator that points to \nTAIL\n! Note: This iterator does \nNOT\n point to the last value in\nyour list!\n\n\nHere is an example of how you print the first element in myList using an iterator:\n\n\n#include <iostream>\n#include <list>\nusing namespace std;\nint main()\n{\n    list<char> myList;\n    myList.push_back('H');\n\n    list<char>::iterator iter;\n    iter = myList.begin();\n    cout << *iter << endl;\n    return 0;\n}\n\n\n\n\nQ1)\n What do you think is the output?\n\n\nQ2)\n Can you find 2 errors in the following code?\n\n\n#include <iostream>\n#include <list>\nusing namespace std;\nint main()\n{\n    list<char> myList;\n    myList.push_back('H');\n\n    list<char>::iterator iter;\n    iter = myList.end();\n    cout << iter << endl;\n    return 0;\n}\n\n\n\n\nAnd this is how you \"iterate\" (use this word!) through a list using a for loop and iterators:\n\n\nfor (list<char>::iterator it = myList.begin(); it != myList.end(); ++it) {\n        cout << ' ' << *it;\n    }\n\n\n\n\nChallenge 1)\n Come up with code (just the main function) which will fill a list with integers 1 through 10.\nThen, use \nIterators\n to print the list in reverse order, separated by spaces!\n\n\nHint:\n The list also has public member functions \nmyList.remove(5)\n. This automatically searches for the number\nand removes it from the list (not position 5). But there is a function \nmyList.insert(iter, 2)\n, which does not find a number\nfor you, you must find it with an iterator and then pass in the iterator. The insert function will then\ninsert the value passed in at the position where the iterator points to, moving everthing else over.\n\n\nChallenge 2)\n Write out only the lines of code needed to get the myList, that is already filled with\nnumbers 1 through 10, and insert a ZERO after the FIVE.\n\n\nExercise 3 - Queue with two Stacks\n\n\nYour task is to implement a class called \nQueue\n using two stacks \nstd::stack\n.\n\n\nPublic Methods\n\n\nQueue(int c = 256) {cap = c; sz = 0}\nvoid printAll()\nvoid push_q(data_type t)\ndata_type pop_q() // removes and returns the top element\nbool isEmpty() \n\n\n\n\nPrivate Data Fields\n\n\nstack<data_type> s1;\nstack<data_type> s2;\nunsigned sz;  // the number of elements currently being used in Queue\nunsigned cap; // the size of Queue\n\n\n\n\nExercise 3.1 - Template Queue\n\n\nTake your completed queue class and create a queue template to allow your class to have members that use template parameters as types.\n\nQueue\n should now become:\n\n\ntemplate<typename T>\nclass Queue\n{\n    public:\n        // ...  \n    private: \n        // ...\n};\n\n\n\n\nand \nprintAll()\n should now become:\n\n\ntemplate<typename T>\nvoid Queue<T>::printAll()\n{\n    // ...\n}\n\n\n\n\nExercise 3.2 - Exceptions\n\n\nAdd an exception handler that throws a \nruntime_error\n object in the \npop_q()\n and \npush_q()\n function that is caught and handled in the main program. \nDetermine what conditions in \npop_q()\n and \npush_q\n would cause an exception to be thrown.\nWhen the exception is caught in the main program, print the error message passed by throw statement and continue the program. Do not terminate. \n\n\nmain\n should look like the following:\n\n\nint main()\n{\n    string s = \"abcde\";\n    Queue<char> q(s.size());\n    try \n    {\n        // ...\n    }\n    catch ( ... )\n    {\n       // ...\n    }\n\n    return 0;\n}\n\n\n\n\nExample\n\n\nExceptions are not implemented in this example.\n\n\nint main()\n{\n    string s = \"abcde\";\n    Queue<char> q(s.size());\n    for(unsigned i = 0; i < s.size(); ++i)\n    {\n        q.push_q(s.at(i));\n    }\n    q.printAll();\n\n    for(unsigned i = 0; i < 3; ++i)\n    {\n        q.pop_q();\n        q.printAll();\n    }\n    q.push_q('x');\n    q.printAll();\n    q.push_q('y');\n    q.printAll();\n\n    return 0;\n}\n\n\n\n\nOutput (first element is the top element): \n\n\na b c d e \nb c d e \nc d e \nd e \nd e x \nd e x y",
            "title": "Lab Week 3"
        },
        {
            "location": "/lab_week_03/#lab-3-templates-and-exceptions",
            "text": "",
            "title": "Lab 3: Templates and Exceptions"
        },
        {
            "location": "/lab_week_03/#exercise-1-circular-int-queue",
            "text": "For this exercise you will be implementing an array-based queue with circular functionality like the one in Professor Miller's  slides . Implement the functionality in a class called 'Queue' and include the following functions:  Queue();\nvoid enqueue(int n);\nvoid dequeue();\nint getFirst();\nint getLast();\n};  When creating the underlying array, feel free to set a max size of the array like so: int arr[10]; // Max Queue size",
            "title": "Exercise 1- Circular int Queue"
        },
        {
            "location": "/lab_week_03/#exercise-11-exceptions",
            "text": "Using what you have learned about exceptions, throw an exception when the user tries to call the  enqueue(int n); \nfunction when the queue has hit its capacity (max size) or when the user tries to call  getFirst();  or  getLast(); \non an empty queue.",
            "title": "Exercise 1.1. Exceptions"
        },
        {
            "location": "/lab_week_03/#exercise-2-iterators",
            "text": "Definition:  An iterator is any object that, pointing to some element in a range\nof elements (such as an array or a container), \nhas the ability to iterate through the elements of that range using a set of operators (with at least the \nincrement  ++  and dereference  *  operators).  The most obvious form of iterator is a pointer: A pointer can \npoint to elements in an array, and can iterate through them using the increment operator  ++ . But other kinds \nof iterators are possible. For example, each container type (such as a list) has a specific iterator type designed \nto iterate through its elements. Notice that while a pointer is a form of iterator, not all iterators have the same \nfunctionality of pointers.  We will learn about the built-in iterator class for the C++ list class. You can think of this iterator as a super-powered Node* ptr  which will automatically switch to the next node if you call  ptr++ . You can even iterate backwards using  ptr--; \nWow!  Let's say you have a list called  myList .\nYou can call public member functions:  myList.begin()  and  myList.end() . myList.begin()  will return an iterator that points to the \nlist's  HEAD->next .  myList.end();  returns an iterator that points to  TAIL ! Note: This iterator does  NOT  point to the last value in\nyour list!  Here is an example of how you print the first element in myList using an iterator:  #include <iostream>\n#include <list>\nusing namespace std;\nint main()\n{\n    list<char> myList;\n    myList.push_back('H');\n\n    list<char>::iterator iter;\n    iter = myList.begin();\n    cout << *iter << endl;\n    return 0;\n}  Q1)  What do you think is the output?  Q2)  Can you find 2 errors in the following code?  #include <iostream>\n#include <list>\nusing namespace std;\nint main()\n{\n    list<char> myList;\n    myList.push_back('H');\n\n    list<char>::iterator iter;\n    iter = myList.end();\n    cout << iter << endl;\n    return 0;\n}  And this is how you \"iterate\" (use this word!) through a list using a for loop and iterators:  for (list<char>::iterator it = myList.begin(); it != myList.end(); ++it) {\n        cout << ' ' << *it;\n    }  Challenge 1)  Come up with code (just the main function) which will fill a list with integers 1 through 10.\nThen, use  Iterators  to print the list in reverse order, separated by spaces!  Hint:  The list also has public member functions  myList.remove(5) . This automatically searches for the number\nand removes it from the list (not position 5). But there is a function  myList.insert(iter, 2) , which does not find a number\nfor you, you must find it with an iterator and then pass in the iterator. The insert function will then\ninsert the value passed in at the position where the iterator points to, moving everthing else over.  Challenge 2)  Write out only the lines of code needed to get the myList, that is already filled with\nnumbers 1 through 10, and insert a ZERO after the FIVE.",
            "title": "Exercise 2 - Iterators"
        },
        {
            "location": "/lab_week_03/#exercise-3-queue-with-two-stacks",
            "text": "Your task is to implement a class called  Queue  using two stacks  std::stack .  Public Methods  Queue(int c = 256) {cap = c; sz = 0}\nvoid printAll()\nvoid push_q(data_type t)\ndata_type pop_q() // removes and returns the top element\nbool isEmpty()   Private Data Fields  stack<data_type> s1;\nstack<data_type> s2;\nunsigned sz;  // the number of elements currently being used in Queue\nunsigned cap; // the size of Queue",
            "title": "Exercise 3 - Queue with two Stacks"
        },
        {
            "location": "/lab_week_03/#exercise-31-template-queue",
            "text": "Take your completed queue class and create a queue template to allow your class to have members that use template parameters as types. Queue  should now become:  template<typename T>\nclass Queue\n{\n    public:\n        // ...  \n    private: \n        // ...\n};  and  printAll()  should now become:  template<typename T>\nvoid Queue<T>::printAll()\n{\n    // ...\n}",
            "title": "Exercise 3.1 - Template Queue"
        },
        {
            "location": "/lab_week_03/#exercise-32-exceptions",
            "text": "Add an exception handler that throws a  runtime_error  object in the  pop_q()  and  push_q()  function that is caught and handled in the main program. \nDetermine what conditions in  pop_q()  and  push_q  would cause an exception to be thrown.\nWhen the exception is caught in the main program, print the error message passed by throw statement and continue the program. Do not terminate.   main  should look like the following:  int main()\n{\n    string s = \"abcde\";\n    Queue<char> q(s.size());\n    try \n    {\n        // ...\n    }\n    catch ( ... )\n    {\n       // ...\n    }\n\n    return 0;\n}",
            "title": "Exercise 3.2 - Exceptions"
        },
        {
            "location": "/lab_week_03/#example",
            "text": "Exceptions are not implemented in this example.  int main()\n{\n    string s = \"abcde\";\n    Queue<char> q(s.size());\n    for(unsigned i = 0; i < s.size(); ++i)\n    {\n        q.push_q(s.at(i));\n    }\n    q.printAll();\n\n    for(unsigned i = 0; i < 3; ++i)\n    {\n        q.pop_q();\n        q.printAll();\n    }\n    q.push_q('x');\n    q.printAll();\n    q.push_q('y');\n    q.printAll();\n\n    return 0;\n}  Output (first element is the top element):   a b c d e \nb c d e \nc d e \nd e \nd e x \nd e x y",
            "title": "Example"
        },
        {
            "location": "/lab_week_04/",
            "text": "Lab 4: Binary Trees\n\n\nExercise 1- Using BST's\n\n\nTo help you understand how a Binary Search Tree works, we've gone ahead and written a BST class which you can get by\ncopying and pasting the following command into your cloud 9 terminal: \ngit clone https://github.com/gpric001/cs14\n\n\nAfter downloading the files, you will notice an empty main.cpp and BST object and header files. Using this main\ntemplate, perform the following tasks\n\n\n\n\nInsert 5 elements, \n3\n, \n6\n, \n7\n, \n0\n, \n1\n into the tree\n\n\nWrite out the pre, in, and post order traversals of the tree and see if you got them right\n\n\nInsert 8 more elements, \n4\n, \n5\n, \n2\n, \n8\n, \n9\n, \n10\n, \n11\n and draw out the tree, marking where 2 should be. What is the height of this tree?\n\n\nPrint out the in order traversal to see if you are correct\n\n\nRemove nodes \n5\n, \n4\n, \n2\n, \n1\n, and \n0\n. Do you notice anything unique about this tree? Print out a traversal of your choice to see if you are correct about the tree structure.\n\n\nWhat is the run time to find node \n11\n in this new tree?\n\n\n\n\nExercise 1.1. Num Nodes\n\n\nUsing the provided BST code, implement a function \nnumNodes(Node*);\n that returns the total number of nodes in the BST.\n\n\nExercise 1.2 - Depth\n\n\nFor this excercise, write a function \ndepth(Node*, unsigned);\n that returns the depth of the node passed in in the tree.\nTo review, the 'Depth' of a node is defined as the number of ancestors for any given node. In the following tree,\n\n\n\n\nThe depth of the node \n3\n is one since it has only one ancestor. The depth of the node \n13\n is 3 since it has 3 ancestors.\nKeep in mind that the depth of the node \n8\n is indeed 0 as it has no ancestors, it is the \nhead\n of the tree.\n\n\nExercise 1.3 - Child Swap\n\n\nNo, this is not the latest reality TV show\n\n\n\n\nYour task is to implement a function that swaps the left and right child of each node in the tree. For example, \n\n\n\n\nIn the image you can see how the node \n3\n was once the left child of node \n1\n and node \n2\n was the right \nchild of node \n1\n. However, after the swap we can now see that nodes \n3\n and \n2\n have switched places, \nas well as any of the other nodes in the tree (nodes \n4\n and \n5\n).\n\n\nExercise 1.4 - Tree Merge\n\n\nIn this excercise, create a function \nmergeTrees(Node* treeOne, Node* treeTwo)\n that takes in two \nNode*\n's \nto the head of two different treees and 'merges' the two trees together. That is \nto say that take all the nodes from tree one, and add them appropriately to the tree with a inorder traversal.\nFor example, if the tree you are trying to add looks like:\n\n\n\n\nThe the order of elements added should be:  \n20\n, \n30\n, \n40\n, \n50\n, \n90\n, \n100\n.",
            "title": "Lab Week 4"
        },
        {
            "location": "/lab_week_04/#lab-4-binary-trees",
            "text": "",
            "title": "Lab 4: Binary Trees"
        },
        {
            "location": "/lab_week_04/#exercise-1-using-bsts",
            "text": "To help you understand how a Binary Search Tree works, we've gone ahead and written a BST class which you can get by\ncopying and pasting the following command into your cloud 9 terminal:  git clone https://github.com/gpric001/cs14  After downloading the files, you will notice an empty main.cpp and BST object and header files. Using this main\ntemplate, perform the following tasks   Insert 5 elements,  3 ,  6 ,  7 ,  0 ,  1  into the tree  Write out the pre, in, and post order traversals of the tree and see if you got them right  Insert 8 more elements,  4 ,  5 ,  2 ,  8 ,  9 ,  10 ,  11  and draw out the tree, marking where 2 should be. What is the height of this tree?  Print out the in order traversal to see if you are correct  Remove nodes  5 ,  4 ,  2 ,  1 , and  0 . Do you notice anything unique about this tree? Print out a traversal of your choice to see if you are correct about the tree structure.  What is the run time to find node  11  in this new tree?",
            "title": "Exercise 1- Using BST's"
        },
        {
            "location": "/lab_week_04/#exercise-11-num-nodes",
            "text": "Using the provided BST code, implement a function  numNodes(Node*);  that returns the total number of nodes in the BST.",
            "title": "Exercise 1.1. Num Nodes"
        },
        {
            "location": "/lab_week_04/#exercise-12-depth",
            "text": "For this excercise, write a function  depth(Node*, unsigned);  that returns the depth of the node passed in in the tree.\nTo review, the 'Depth' of a node is defined as the number of ancestors for any given node. In the following tree,   The depth of the node  3  is one since it has only one ancestor. The depth of the node  13  is 3 since it has 3 ancestors.\nKeep in mind that the depth of the node  8  is indeed 0 as it has no ancestors, it is the  head  of the tree.",
            "title": "Exercise 1.2 - Depth"
        },
        {
            "location": "/lab_week_04/#exercise-13-child-swap",
            "text": "No, this is not the latest reality TV show   Your task is to implement a function that swaps the left and right child of each node in the tree. For example,    In the image you can see how the node  3  was once the left child of node  1  and node  2  was the right \nchild of node  1 . However, after the swap we can now see that nodes  3  and  2  have switched places, \nas well as any of the other nodes in the tree (nodes  4  and  5 ).",
            "title": "Exercise 1.3 - Child Swap"
        },
        {
            "location": "/lab_week_04/#exercise-14-tree-merge",
            "text": "In this excercise, create a function  mergeTrees(Node* treeOne, Node* treeTwo)  that takes in two  Node* 's \nto the head of two different treees and 'merges' the two trees together. That is \nto say that take all the nodes from tree one, and add them appropriately to the tree with a inorder traversal.\nFor example, if the tree you are trying to add looks like:   The the order of elements added should be:   20 ,  30 ,  40 ,  50 ,  90 ,  100 .",
            "title": "Exercise 1.4 - Tree Merge"
        },
        {
            "location": "/midterm/",
            "text": "SI Mock Midterm!\n\n\nClick on the following words to go to the \nSI Mock Midterm!\n\n\nClick on the following words to see the \nMock Midterm Answer Key!\n\n\nGood luck!!",
            "title": "Mock Midterm Week 5"
        },
        {
            "location": "/midterm/#si-mock-midterm",
            "text": "Click on the following words to go to the  SI Mock Midterm!  Click on the following words to see the  Mock Midterm Answer Key!  Good luck!!",
            "title": "SI Mock Midterm!"
        },
        {
            "location": "/lab_week_05/",
            "text": "Lab 5: Binary Tree Applications\n\n\nTo do this excercise, first type into your terminal the following command:\n\ngit clone https://github.com/Andre-Castro/cs14\n. You should now see a folder with multiple .h,\n.o and one main.cpp file.\n\n\nExercise 1 - Arithmetic Expression Trees\n\n\nUsing the files provided for you from the git clone, we will be working with an arithmetic expression tree\n(If you have had lab for this week, yes it is the same arithemetic expression trees you will be using in lab!).\n\n\nCreate a function \nevaluate()\n that takes the expression and evaluates the result.\nFor example, given the expression: \n\"1+5/2*4+3-1\"\n, the evaluation shold return 10 (using integer division).\n\n\nHuffman Trees\n\n\nIntroduction\n\n\nHuffman coding\n is a lossless data compression algorithm. The idea is to assign variable-length \ncodes to input characters, lengths of the assigned codes are based on the frequencies of \ncorresponding characters. The most frequent character gets the smallest code and the least frequent \ncharacter gets the largest code. -Wikipedia\n\n Basically, let's say you have a message \"M\". By using Huffman coding, you can determine a coding\nscheme for each letter in message \"M\". \n\n For example, \nthe letter \"A\" will be \"10\",\n\nthe letter \"B\" will be \"11\", and \n\nthe letter \"C\" will be \"0\".\n\nSo, you can \nencode\n the message \"ABC\" as \"10110\".\n\nSee?\n\nWell, anyway the point of Huffman coding is so that when you convert your message of characters\ninto a long list of zeros and ones, it will be \nas short as possible\n, otherwise known as \n\noptimal\n. The coding scheme is different for every message. There are usually more than one\nway to make the Huffman tree. Here is how the tree looks like for our example:\n\n\n\nThe whole point of the tree is so that we can traverse it like a BST! To decode the message,\nMake a for loop that iterates through the string \"10110\". You start at the root, \nthen \ngo left if you see a '0' or go right if you see a '1'\n. Try it by tracing through the tree!\nThe first character in \"10110\" is a '1' so let's start at the root and then go RIGHT.\nOk. Now the next character is a '0' so let's go LEFT. KAPOOYAH! Now we know the first\nletter is 'A'. Cool, huh?\n\n\nExercise 2\n\n\nOk, you don't have to worry about the Huffman encoding (you'll learn that in CS141). So we'll\nuse an online tool.\n1. Make a secret message for the person next to you! Please try to keep it short \n       (like 1-3 short words). and try not to use too many different letters otherwise it \n       will be crazy for your partner!\n\n\n\n\n\n\nGo to http://huffman.ooz.ie/\n\n\n\n\n\n\nType in your message and then click \"generate a tree\" at the top. \n\n\n\n\n\n\nNow encode your messsage by looking at the codes at each leaf of your tree. Send the picture\n       of your tree and your secret message of zeros and ones to your partner!\n\n\n\n\n\n\nNow you should have someone else's tree and secret message. Make the tree in C++! internal \n       nodes do not need any value just the leaves which should have the letter as a string.\n\n\n\n\n\n\nLastly, make a function called Decode() that takes in a string of zeros and ones and prints\n       the decoded message! Read the \"introduction\" section above to see how the tree is used to decode\n    (Go left if you see a zero and go right if you see a one).",
            "title": "Lab Week 5"
        },
        {
            "location": "/lab_week_05/#lab-5-binary-tree-applications",
            "text": "To do this excercise, first type into your terminal the following command: git clone https://github.com/Andre-Castro/cs14 . You should now see a folder with multiple .h,\n.o and one main.cpp file.",
            "title": "Lab 5: Binary Tree Applications"
        },
        {
            "location": "/lab_week_05/#exercise-1-arithmetic-expression-trees",
            "text": "Using the files provided for you from the git clone, we will be working with an arithmetic expression tree\n(If you have had lab for this week, yes it is the same arithemetic expression trees you will be using in lab!).  Create a function  evaluate()  that takes the expression and evaluates the result.\nFor example, given the expression:  \"1+5/2*4+3-1\" , the evaluation shold return 10 (using integer division).",
            "title": "Exercise 1 - Arithmetic Expression Trees"
        },
        {
            "location": "/lab_week_05/#huffman-trees",
            "text": "",
            "title": "Huffman Trees"
        },
        {
            "location": "/lab_week_05/#introduction",
            "text": "Huffman coding  is a lossless data compression algorithm. The idea is to assign variable-length \ncodes to input characters, lengths of the assigned codes are based on the frequencies of \ncorresponding characters. The most frequent character gets the smallest code and the least frequent \ncharacter gets the largest code. -Wikipedia  Basically, let's say you have a message \"M\". By using Huffman coding, you can determine a coding\nscheme for each letter in message \"M\".   For example, \nthe letter \"A\" will be \"10\", \nthe letter \"B\" will be \"11\", and  \nthe letter \"C\" will be \"0\". \nSo, you can  encode  the message \"ABC\" as \"10110\". \nSee? \nWell, anyway the point of Huffman coding is so that when you convert your message of characters\ninto a long list of zeros and ones, it will be  as short as possible , otherwise known as  optimal . The coding scheme is different for every message. There are usually more than one\nway to make the Huffman tree. Here is how the tree looks like for our example:  The whole point of the tree is so that we can traverse it like a BST! To decode the message,\nMake a for loop that iterates through the string \"10110\". You start at the root, \nthen  go left if you see a '0' or go right if you see a '1' . Try it by tracing through the tree!\nThe first character in \"10110\" is a '1' so let's start at the root and then go RIGHT.\nOk. Now the next character is a '0' so let's go LEFT. KAPOOYAH! Now we know the first\nletter is 'A'. Cool, huh?",
            "title": "Introduction"
        },
        {
            "location": "/lab_week_05/#exercise-2",
            "text": "Ok, you don't have to worry about the Huffman encoding (you'll learn that in CS141). So we'll\nuse an online tool.\n1. Make a secret message for the person next to you! Please try to keep it short \n       (like 1-3 short words). and try not to use too many different letters otherwise it \n       will be crazy for your partner!    Go to http://huffman.ooz.ie/    Type in your message and then click \"generate a tree\" at the top.     Now encode your messsage by looking at the codes at each leaf of your tree. Send the picture\n       of your tree and your secret message of zeros and ones to your partner!    Now you should have someone else's tree and secret message. Make the tree in C++! internal \n       nodes do not need any value just the leaves which should have the letter as a string.    Lastly, make a function called Decode() that takes in a string of zeros and ones and prints\n       the decoded message! Read the \"introduction\" section above to see how the tree is used to decode\n    (Go left if you see a zero and go right if you see a one).",
            "title": "Exercise 2"
        },
        {
            "location": "/lec_week_06/",
            "text": "Part I: AVL Trees\n\n\nThe following questions are in regards to AVL Trees. If you have't done the \nreading for this chapter, I suggest skipping Part I and attempting Part II.\n\n\nQuestion 1\n\nWhat is the relationship between the balance factor of a node and the height\nof the node's children?\n\n\nQuestion 2\n\nWhat is the relationship between the balance factor and the direction of\nrotation when rebalancing?\n\n\nThe following questions are in regard to the AVL Tree below.\n\n\n\n\nQuestion 3\n\nMark the height and balance factor for each node.\n\n\nQuestion 4\n\nWhat does the tree look like after the following operations? Be sure to\ndraw the relevant sections of the tree after each operation.\n\n\n\n\ntree.insert(33);\n\n\ntree.insert(26);\n\n\ntree.insert(37);\n\n\ntree.insert(39);\n\n\n\n\nUse the following site to verify your AVL Trees: [Click me!][AVLCheck] \n\n\nPart II: 2-3 Trees\n\n\n2-3 Trees are trees that have properties that keep it \nbalanced\n and ordered. The benefit of this \nis that traversal algorithms will always have a worst case runtime of O(log(n)). Unlike a generic\ntree, this tree will never end up looking like a diagonal linked list. This is great if you have\na lot of data and want to search through it quicikly! \n \n\nSome properties include:\n\n\n\n\nAll leaves are always on the same level (bottom)\n\n\nEach node can have up to \n2\n values and up to \n3\n children\n\n\nThere can not exist a parent with only 1 child (unbalanced)\n\n\n\n\nInsertion Exercises\n\n\nHere is a BST that had the numbers 39 through 32 inserted.\n\n\nredraw the tree without the gray insertions and reinsert 39 through 32 (in descending order)\nas a 2-3 tree.\n\nHint 1:\n After inserting 36, the root should have 2 values and 3 children.\n\nHint 2:\n After inserting 32, the tree should have a height of 3.\n\n\nDeleting Exercises\n\n\n\n\n\nNow try deleting 100 from the following tree!\n\n\nTry it with strings!\n\n\n\n\n\nRemoval Exercises",
            "title": "AVL Trees"
        },
        {
            "location": "/lec_week_06/#part-i-avl-trees",
            "text": "The following questions are in regards to AVL Trees. If you have't done the \nreading for this chapter, I suggest skipping Part I and attempting Part II.  Question 1 \nWhat is the relationship between the balance factor of a node and the height\nof the node's children?  Question 2 \nWhat is the relationship between the balance factor and the direction of\nrotation when rebalancing?  The following questions are in regard to the AVL Tree below.   Question 3 \nMark the height and balance factor for each node.  Question 4 \nWhat does the tree look like after the following operations? Be sure to\ndraw the relevant sections of the tree after each operation.   tree.insert(33);  tree.insert(26);  tree.insert(37);  tree.insert(39);   Use the following site to verify your AVL Trees: [Click me!][AVLCheck]",
            "title": "Part I: AVL Trees"
        },
        {
            "location": "/lec_week_06/#part-ii-2-3-trees",
            "text": "2-3 Trees are trees that have properties that keep it  balanced  and ordered. The benefit of this \nis that traversal algorithms will always have a worst case runtime of O(log(n)). Unlike a generic\ntree, this tree will never end up looking like a diagonal linked list. This is great if you have\na lot of data and want to search through it quicikly!    Some properties include:   All leaves are always on the same level (bottom)  Each node can have up to  2  values and up to  3  children  There can not exist a parent with only 1 child (unbalanced)",
            "title": "Part II: 2-3 Trees"
        },
        {
            "location": "/lec_week_06/#insertion-exercises",
            "text": "Here is a BST that had the numbers 39 through 32 inserted. \nredraw the tree without the gray insertions and reinsert 39 through 32 (in descending order)\nas a 2-3 tree. Hint 1:  After inserting 36, the root should have 2 values and 3 children. Hint 2:  After inserting 32, the tree should have a height of 3.",
            "title": "Insertion Exercises"
        },
        {
            "location": "/lec_week_06/#deleting-exercises",
            "text": "Now try deleting 100 from the following tree! \nTry it with strings!",
            "title": "Deleting Exercises"
        },
        {
            "location": "/lec_week_06/#removal-exercises",
            "text": "",
            "title": "Removal Exercises"
        },
        {
            "location": "/lab_week_06/",
            "text": "Lab 5: AVL Trees\n\n\nTo do the following excercises, first type into your terminal the following command:\n\ngit clone https://github.com/Andre-Castro/cs14Spr17Week6\n. You should now see a folder with a single\n.h file and a single .o file.\n\n\nFeel free to use the following site to double check the correctnes of your AVL Trees: \nClick me!\n \n\n\nExercise 1 - Remove\n\n\nMake a function \nvoid remove(const string &);\n that removes the node with the specified value from the tree.\n\nBe sure\n to keep the properties of an balanced tree. \n\n\nFor example, in the following tree:\n\n\n\n\nThe removal of node f would look like:\n\n\n\n\nAnd the subsequent remval of nodes \ne\n and \ng\n would look like:\n\n\n\n\nFor more help on AVL Tree deletions check out the following link: \nAVL Tree Deletions",
            "title": "Lab Week 6"
        },
        {
            "location": "/lab_week_06/#lab-5-avl-trees",
            "text": "To do the following excercises, first type into your terminal the following command: git clone https://github.com/Andre-Castro/cs14Spr17Week6 . You should now see a folder with a single\n.h file and a single .o file.  Feel free to use the following site to double check the correctnes of your AVL Trees:  Click me!",
            "title": "Lab 5: AVL Trees"
        },
        {
            "location": "/lab_week_06/#exercise-1-remove",
            "text": "Make a function  void remove(const string &);  that removes the node with the specified value from the tree. Be sure  to keep the properties of an balanced tree.   For example, in the following tree:   The removal of node f would look like:   And the subsequent remval of nodes  e  and  g  would look like:   For more help on AVL Tree deletions check out the following link:  AVL Tree Deletions",
            "title": "Exercise 1 - Remove"
        },
        {
            "location": "/lab_week_07/",
            "text": "Lab Week 7: Hash Tables\n\n\nThe following exercises require some code we have written. Execute the following\ncommand on c9 (or on the terminal) to get it.\n\n\ngit clone https://github.com/gpric001/cs14\n\n\nYou should now have a directory called cs14/w7 with the following files: \n\nPerson.h\n, \nUnorderedSet.h\n, \nUnorderedSet.cpp\n, \nmain.cpp\n, and \npersondata.txt\n.\n\n\nThe \nPerson.h\n file contains the Actor struct which has a variety of fields.\n\n\nThe \nUnorderedSet.h\n file contains the basic interface of the UnorderedSet class.\n\n\nThe \nUnorderedSet.cpp\n file is where you will be implmenting the UnorderedSet\nclass.\n\n\nThe \nmain.cpp\n file is where you should write your tests. Right now it simply\nloads the person data into a vector.\n\n\nThe \npersondata.txt\n file contains the raw person data\n\n\nExercise 1\n\n\nOur goal in this exercise is to implement an ADT that uses the ideas in class to\nhash Person structs. Hopefully we can attain O(1) insert and remove operations.\n\n\nUsing the UnorderedSet class declartion in UnorderedSet.h, implement the the\nUnorderedSet class. Feel free to modify UnorderedSet.h but your implementation \nof the UnorderedSet class must at least support the following public member\nfunctions:\n\n\nint count(const Person& elem)\nvoid remove(const Person& elem) \nvoid insert(const Person& elem)\n\n\n\n\nReview the files given for hints on how to implement this class. As always,\nif you are having trouble ask your neighbor or the SI leader for help.\n\n\nExercise 2\n\n\nWrite a test for your UnorderedSet class that reports how the elements are \ndistributed in your set. One way to do this is to sum the total number of\nelements in each bucket and divide by the total number of buckets that have at\nleast one element.\n\n\nIf you use the above suggestion, what kind of output do you want to see for your\ntest?\n\n\nExercise 3\n\n\nImplement the \nresize()\n public member function. \nresize()\n should double the \nnumber of buckets if the load factor goes above a certain threshold. Do some\nquick research online to determine an appropriate load factor threshold.",
            "title": "Lab Week 7"
        },
        {
            "location": "/lab_week_07/#lab-week-7-hash-tables",
            "text": "The following exercises require some code we have written. Execute the following\ncommand on c9 (or on the terminal) to get it.  git clone https://github.com/gpric001/cs14  You should now have a directory called cs14/w7 with the following files:  Person.h ,  UnorderedSet.h ,  UnorderedSet.cpp ,  main.cpp , and  persondata.txt .  The  Person.h  file contains the Actor struct which has a variety of fields.  The  UnorderedSet.h  file contains the basic interface of the UnorderedSet class.  The  UnorderedSet.cpp  file is where you will be implmenting the UnorderedSet\nclass.  The  main.cpp  file is where you should write your tests. Right now it simply\nloads the person data into a vector.  The  persondata.txt  file contains the raw person data",
            "title": "Lab Week 7: Hash Tables"
        },
        {
            "location": "/lab_week_07/#exercise-1",
            "text": "Our goal in this exercise is to implement an ADT that uses the ideas in class to\nhash Person structs. Hopefully we can attain O(1) insert and remove operations.  Using the UnorderedSet class declartion in UnorderedSet.h, implement the the\nUnorderedSet class. Feel free to modify UnorderedSet.h but your implementation \nof the UnorderedSet class must at least support the following public member\nfunctions:  int count(const Person& elem)\nvoid remove(const Person& elem) \nvoid insert(const Person& elem)  Review the files given for hints on how to implement this class. As always,\nif you are having trouble ask your neighbor or the SI leader for help.",
            "title": "Exercise 1"
        },
        {
            "location": "/lab_week_07/#exercise-2",
            "text": "Write a test for your UnorderedSet class that reports how the elements are \ndistributed in your set. One way to do this is to sum the total number of\nelements in each bucket and divide by the total number of buckets that have at\nleast one element.  If you use the above suggestion, what kind of output do you want to see for your\ntest?",
            "title": "Exercise 2"
        },
        {
            "location": "/lab_week_07/#exercise-3",
            "text": "Implement the  resize()  public member function.  resize()  should double the \nnumber of buckets if the load factor goes above a certain threshold. Do some\nquick research online to determine an appropriate load factor threshold.",
            "title": "Exercise 3"
        },
        {
            "location": "/lec_week_08/",
            "text": "Inserstion Sort\n\n\nAnother type of sort called insertion sort sorts a list of elements as they are inserted into the array.\nThe values inserted are compared to each of the other values in the list until the correct posistion of \nthe element is found.\n\n\nFor example, in the following image, the given array is sorted with insertion sort.\n\n\n\n\nFirstly, the first value in the array, \n5\n, is inserted to an empty list, which is of course sorted.\nSecondly, the next value in the array, \n1\n, is inserted. Since the list is not empty, the value being\ninserted has to be compared to the other values in the list. Since 1 is less than 5 and this list is being\nsorted in ascending order, the two values \n1\n and \n5\n have to be swapped. This process is repeated until the\nlist no longer has values to sort.\n\n\nThis sort runs in \nO(n^2)\n time, but has an \nO(n)\n best case.\n\n\nExcercises:\n\n\n\n\nGiven a list: \n0,9,4,2,7,4\n, perform insertion sort on the list, showing each step of the way.\n\n\nWhat would the lists look like when insertion sort runs in O(n^2) time? What about for O(n) time?\n\n\n\n\nQuick Sort\n\n\nQuick Sort, like Merge Sort, is a divide and conquer sorting algorithm. Similar in many ways to merge sort,\nit differs by the position where we choose the split the values in our list. In merge sort, the list is always\nsplit right down the middle, gauranteeing an \nO(nlogn)\n runtime. However, with quick sort, we can choose where\nwe want to split the list, and can also split the list in multiple places. The places that we choose are\ncalled \npivots\n.\n\n\n\n\nQuick Sort runs on average faster than a majority of the other sorts. However, with poorly chosen pivots,\nQuick Sort can run in \nO(n^2)\n time.\n\n\nExcercises:\n\n\n\n\ns\n\n\nu\n\n\n\n\nIn Place and Stable Sorts\n\n\nA sorting algorithm can be described with two different classifiers: \"in-place\" and \"stable\".\n\n\nA stable sorting algorithm is one that when comparing values that are equal, does not perform a swap.\nThat is to say that the sorting algorithm is more stable because the values in the list do not change\nthier position if they are equal.\n\n\nAn inplace sorting algorithm is one that sorts the values of the list within the list itself. It does\nnot create another list to copy the values into, all the sorting is done within the list itself.",
            "title": "Lecture Week 8"
        },
        {
            "location": "/lec_week_08/#inserstion-sort",
            "text": "Another type of sort called insertion sort sorts a list of elements as they are inserted into the array.\nThe values inserted are compared to each of the other values in the list until the correct posistion of \nthe element is found.  For example, in the following image, the given array is sorted with insertion sort.   Firstly, the first value in the array,  5 , is inserted to an empty list, which is of course sorted.\nSecondly, the next value in the array,  1 , is inserted. Since the list is not empty, the value being\ninserted has to be compared to the other values in the list. Since 1 is less than 5 and this list is being\nsorted in ascending order, the two values  1  and  5  have to be swapped. This process is repeated until the\nlist no longer has values to sort.  This sort runs in  O(n^2)  time, but has an  O(n)  best case.  Excercises:   Given a list:  0,9,4,2,7,4 , perform insertion sort on the list, showing each step of the way.  What would the lists look like when insertion sort runs in O(n^2) time? What about for O(n) time?",
            "title": "Inserstion Sort"
        },
        {
            "location": "/lec_week_08/#quick-sort",
            "text": "Quick Sort, like Merge Sort, is a divide and conquer sorting algorithm. Similar in many ways to merge sort,\nit differs by the position where we choose the split the values in our list. In merge sort, the list is always\nsplit right down the middle, gauranteeing an  O(nlogn)  runtime. However, with quick sort, we can choose where\nwe want to split the list, and can also split the list in multiple places. The places that we choose are\ncalled  pivots .   Quick Sort runs on average faster than a majority of the other sorts. However, with poorly chosen pivots,\nQuick Sort can run in  O(n^2)  time.  Excercises:   s  u",
            "title": "Quick Sort"
        },
        {
            "location": "/lec_week_08/#in-place-and-stable-sorts",
            "text": "A sorting algorithm can be described with two different classifiers: \"in-place\" and \"stable\".  A stable sorting algorithm is one that when comparing values that are equal, does not perform a swap.\nThat is to say that the sorting algorithm is more stable because the values in the list do not change\nthier position if they are equal.  An inplace sorting algorithm is one that sorts the values of the list within the list itself. It does\nnot create another list to copy the values into, all the sorting is done within the list itself.",
            "title": "In Place and Stable Sorts"
        },
        {
            "location": "/lab_week_09/",
            "text": "Lab Week 9: Graphs\n\n\nGraphs are defined as consisting of a set \nV\n of vertices\nand a set \nE\n of edges. Edges are further defined as being\neither an ordered pair of vertices (in the case of a directed\ngraph), or an unordered pair (in the case of an undirected\ngraph).\n\n\nImplementation\n\n\nThe two primary ways that graphs are implemented are as an\nadjacency matrix or as an adjacency list. An adjacency matrix\nconsists of a two dimensional array where the indices map to\nthe vertices and the intersections between every pair of vertices\nindicate whether there is an edge connecting them and if so\nwhat the weight of that edge is (in the case of a weighted\ngraph). The image below should help to illustrate this.\n\n\n\n\nThis class definition should help give you an idea of where to\nstart when implementing a graph as an adjacency matrix.\n\n\nclass AdjacencyMatrix{\n    private:\n        int n;\n        int **adj;\n        bool *visited;\n    public:\n        AdjacencyMatrix(int n);\n        ~AdjacencyMatrix();\n        void add_edge(int origin, int destin, int weight);\n        void display();\n        /* etc. */\n};\n\n\n\n\nAdjacency lists conserve more space by using lists of edges\nstored at each vertex to represent adjacencies instead of an\nn by n matrix. In an adjacency list we store a list for\n\neach node that contains the edges for that node. Each element\nin that list represents an edge in the graph and contains\ninformation such as the starting and ending vertices as well\nas the edge weight. The image below illustrates this.\n\n\n\n\nSince we need to create nodes for the vertices and edges we can\nnow add other useful attributes to each vertex to help us with our\nalgorithms. For example, a color attribute for use with a graph\ncoloring algorithm or a visited attribute for a graph traversal\nalgorithm. The implementation consists of three classes; the \n\nAdjacency_List\n class, the \nVertex\n class and the \nEdge\n class. \nIf you notice in the example below, the Vertex class contains a list\nof edges and the Edge class contains a pointer to both a starting \nand ending vertex.\n\n\nclass Vertex{\n    private:\n        vector<Edge*> Adjacencys;\n        int color;\n        bool visited;\n    public:\n        Vertex();\n        ~Vertex();\n};\n\nclass Edge{\n    private:\n        Vertex *from;\n        Vertex *to;\n        int weight;\n    public:\n        Edge();\n        ~Edge();\n};\n\nclass AdjacencyList{\n    private:\n        vector<Vertex*> Vertices;\n    public:\n        Graph();\n        ~Graph();\n        void add_edge(Vertex *from, Vertex *to, int weight);\n        void add_edge(int from, int to, int weight);\n        void display();\n        /* etc. */\n};\n\n\n\n\nDFS and BFS\n\n\nDepth First Search (DFS) and Breadth First Search (BFS) are the two\nprimary search algorithms that all other algorithms use to  traverse\na graph. A depth first search will start at the given node and add\nall of the unvisited adjacent nodes to a stack. It will then mark the current node as visited and repeat the process on the next node which it pops off of the stack. This process repeats until all of the vertices have been visited and the stack is empty. A breadth first search, on the other hand, starts at the given vertex and then adds all of its adjacent vertices to a queue. When this is complete, the algorithm marks the vertex as visited and moves on the the next vertex in the queue. It repeats this process until all of the vertices have been visited and and the queue is empty. The easiest way to remember these essential algorithms is to mentally link DFS to Stacks and BFS to Queues.\n\n\nExercise 1\n\n\nImplement a Graph class using either the Adjacency Matrix or the\nAdjacency list approach. Feel free to use the code given above\nto help you get started.\n\n\nExercise 2\n\n\nA cycle is any point in a graph where it is possible to travel in a\nloop. For example; there is an edge from A to B, from B to C, and\nfrom C back to A. Write a member function that detects whether your\ngraph contains any cycles and returns true or false respectively.\n\n\nExercise 3\n\n\nWrite a member function that, given a starting vertex and an ending\nvertex, prints out a list of vertices that connect a path between\nthem.\n\n\nStretch-goal exercise:\n\n\nCan you come up with an algorithm that finds the shortest\npath between two given vertices?",
            "title": "Lab Week 9"
        },
        {
            "location": "/lab_week_09/#lab-week-9-graphs",
            "text": "Graphs are defined as consisting of a set  V  of vertices\nand a set  E  of edges. Edges are further defined as being\neither an ordered pair of vertices (in the case of a directed\ngraph), or an unordered pair (in the case of an undirected\ngraph).",
            "title": "Lab Week 9: Graphs"
        },
        {
            "location": "/lab_week_09/#implementation",
            "text": "The two primary ways that graphs are implemented are as an\nadjacency matrix or as an adjacency list. An adjacency matrix\nconsists of a two dimensional array where the indices map to\nthe vertices and the intersections between every pair of vertices\nindicate whether there is an edge connecting them and if so\nwhat the weight of that edge is (in the case of a weighted\ngraph). The image below should help to illustrate this.   This class definition should help give you an idea of where to\nstart when implementing a graph as an adjacency matrix.  class AdjacencyMatrix{\n    private:\n        int n;\n        int **adj;\n        bool *visited;\n    public:\n        AdjacencyMatrix(int n);\n        ~AdjacencyMatrix();\n        void add_edge(int origin, int destin, int weight);\n        void display();\n        /* etc. */\n};  Adjacency lists conserve more space by using lists of edges\nstored at each vertex to represent adjacencies instead of an\nn by n matrix. In an adjacency list we store a list for \neach node that contains the edges for that node. Each element\nin that list represents an edge in the graph and contains\ninformation such as the starting and ending vertices as well\nas the edge weight. The image below illustrates this.   Since we need to create nodes for the vertices and edges we can\nnow add other useful attributes to each vertex to help us with our\nalgorithms. For example, a color attribute for use with a graph\ncoloring algorithm or a visited attribute for a graph traversal\nalgorithm. The implementation consists of three classes; the  Adjacency_List  class, the  Vertex  class and the  Edge  class. \nIf you notice in the example below, the Vertex class contains a list\nof edges and the Edge class contains a pointer to both a starting \nand ending vertex.  class Vertex{\n    private:\n        vector<Edge*> Adjacencys;\n        int color;\n        bool visited;\n    public:\n        Vertex();\n        ~Vertex();\n};\n\nclass Edge{\n    private:\n        Vertex *from;\n        Vertex *to;\n        int weight;\n    public:\n        Edge();\n        ~Edge();\n};\n\nclass AdjacencyList{\n    private:\n        vector<Vertex*> Vertices;\n    public:\n        Graph();\n        ~Graph();\n        void add_edge(Vertex *from, Vertex *to, int weight);\n        void add_edge(int from, int to, int weight);\n        void display();\n        /* etc. */\n};",
            "title": "Implementation"
        },
        {
            "location": "/lab_week_09/#dfs-and-bfs",
            "text": "Depth First Search (DFS) and Breadth First Search (BFS) are the two\nprimary search algorithms that all other algorithms use to  traverse\na graph. A depth first search will start at the given node and add\nall of the unvisited adjacent nodes to a stack. It will then mark the current node as visited and repeat the process on the next node which it pops off of the stack. This process repeats until all of the vertices have been visited and the stack is empty. A breadth first search, on the other hand, starts at the given vertex and then adds all of its adjacent vertices to a queue. When this is complete, the algorithm marks the vertex as visited and moves on the the next vertex in the queue. It repeats this process until all of the vertices have been visited and and the queue is empty. The easiest way to remember these essential algorithms is to mentally link DFS to Stacks and BFS to Queues.",
            "title": "DFS and BFS"
        },
        {
            "location": "/lab_week_09/#exercise-1",
            "text": "Implement a Graph class using either the Adjacency Matrix or the\nAdjacency list approach. Feel free to use the code given above\nto help you get started.",
            "title": "Exercise 1"
        },
        {
            "location": "/lab_week_09/#exercise-2",
            "text": "A cycle is any point in a graph where it is possible to travel in a\nloop. For example; there is an edge from A to B, from B to C, and\nfrom C back to A. Write a member function that detects whether your\ngraph contains any cycles and returns true or false respectively.",
            "title": "Exercise 2"
        },
        {
            "location": "/lab_week_09/#exercise-3",
            "text": "Write a member function that, given a starting vertex and an ending\nvertex, prints out a list of vertices that connect a path between\nthem.",
            "title": "Exercise 3"
        },
        {
            "location": "/lab_week_09/#stretch-goal-exercise",
            "text": "Can you come up with an algorithm that finds the shortest\npath between two given vertices?",
            "title": "Stretch-goal exercise:"
        },
        {
            "location": "/lec_week_09/",
            "text": "Breadth First Search (BFS)\n\n\nJust when you thought you were done with traverls after post, in and preorder, here are two more!! (For graphs).\nBut don't fret, they are not that conceptually difficult.\n\n\nThe first graph traversal you will learn about is \"Breadth First Search\" or \nBFS\n for short. BFS starts with a\nnode in the graph, and traverses the graph by visiting all the nodes the shortest distance away first.\nDistance from a node to another node in graphs is the amount of edges between such nodes. Consider a BST with \nthe values 8, 7, and 6 inserted in that order (recall that a tree is just a unique type of graph). Starting at\nnode 8, the amount of edges from node 8 to node 7 would be 1, making node 7 a distance of 1 away from node 8. \nNode 6 on the other hand would be a distance of 2 away from node 8. Therefore, the BFS traversal of this BST\nwould look like \n8,7,6\n since we started at node 8 and then visited the nodes closest next.\n\n\nIf there are multiple nodes the same distance away, the order in which they are visited does not matter. So \na BST with values 8,7,6,9 inserted in that order would have nodes 9 and 7 both a distance of \n1\n away from node 8.\nHowever in the traversal of this tree, the results \n8,7,9,6\n and \n8,9,7,6\n are both valid BFS-es.  \n\n\nConsider the following graph:\n\n\n\n\nWhat would the BFS traversal of this graph look like if we started from node \n1\n? \n\n\nDepth First Search (DFS)\n\n\nDjikstra's Algorithm",
            "title": "Lecture Week 9"
        },
        {
            "location": "/lec_week_09/#breadth-first-search-bfs",
            "text": "Just when you thought you were done with traverls after post, in and preorder, here are two more!! (For graphs).\nBut don't fret, they are not that conceptually difficult.  The first graph traversal you will learn about is \"Breadth First Search\" or  BFS  for short. BFS starts with a\nnode in the graph, and traverses the graph by visiting all the nodes the shortest distance away first.\nDistance from a node to another node in graphs is the amount of edges between such nodes. Consider a BST with \nthe values 8, 7, and 6 inserted in that order (recall that a tree is just a unique type of graph). Starting at\nnode 8, the amount of edges from node 8 to node 7 would be 1, making node 7 a distance of 1 away from node 8. \nNode 6 on the other hand would be a distance of 2 away from node 8. Therefore, the BFS traversal of this BST\nwould look like  8,7,6  since we started at node 8 and then visited the nodes closest next.  If there are multiple nodes the same distance away, the order in which they are visited does not matter. So \na BST with values 8,7,6,9 inserted in that order would have nodes 9 and 7 both a distance of  1  away from node 8.\nHowever in the traversal of this tree, the results  8,7,9,6  and  8,9,7,6  are both valid BFS-es.    Consider the following graph:   What would the BFS traversal of this graph look like if we started from node  1 ?",
            "title": "Breadth First Search (BFS)"
        },
        {
            "location": "/lec_week_09/#depth-first-search-dfs",
            "text": "",
            "title": "Depth First Search (DFS)"
        },
        {
            "location": "/lec_week_09/#djikstras-algorithm",
            "text": "",
            "title": "Djikstra's Algorithm"
        }
    ]
}