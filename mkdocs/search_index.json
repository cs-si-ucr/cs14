{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs14-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS14 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lab_week_01/", 
            "text": "Lab 1: Templates\n\n\nYou may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node. \n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode * next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};\n\n\n\n\nThat's all fine and dandy, but if instead want a \nDoubleList\n or a\n\nStringList\n, then we are in trouble. \n\n\nA common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to \nmake mistakes\n\ncopy and pasting.\n\n\nIntroducing templates!\n\n\nThe solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.\n\n\nIn fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.\n\n\nTo create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".\n\n\nvector\nint\n numbers; // creates a vector of integers\nvector\nstring\n words; // creates a vector of strings\n\n\n\n\nTo create a new class template, before our class declaration we use the keyword \ntemplate\n followed by a type parameter inside \"angle-brackets\"\ne.g. \ntemplate\ntypename T\n. The keyword \ntypename\n tells the compiler\nthat \nT\n is a placeholder for an actual type. \n\n\nNote: \nT\n is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is \nContainer\n\n\nLet's say, we want to create a templated version of our Node and List.\n\n\nIntNode\n becomes:\n\n\ntemplate\ntypename T\n\nstruct Node {\n   T val;\n   Node\nT\n * next;\n};\n\n\n\n\nand \nIntLinkedList\n becomes:\n\n\ntemplate\ntypename T\n\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node\nT\n * head;\n};\n\n\n\n\nTo create a \nLinkedList\n of doubles, we declare the list as so:\n\n\nLinkedList\ndouble\n list;\n\n\n\n\nIn order to template functions and method, we do something similar.\n\n\nFor example, if we want to define the templated LinkedList's\n\npush_front\n method:\n\n\ntemplate\ntypename T\n\nLinkedList\nT\n::push_front(T val) {\n    Node * new_node = new Node\nT\n();\n    new_node -\n val = val;\n\n    Node * old_head = this -\n head;\n    new_node -\n next = old_head;\n    this -\n head = new_node;\n}\n\n\n\n\nFor more info on templates check out \nthis FAQ\n!\n\n\nExercises\n\n\nImplement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier! \n\n\nPro-Tip: before implementing the class as a class template, \ntypedef\n the type \nT\n as an integer and replace type with \nT\n as needed.\n\ne.g.\n\n\ntypedef int T; // give the int an alias which is T\nT my_int = 42;\n\n\n\n\nThis give you much nicer error messages and makes it easier to debug.\n\n\nExample Usage, should implement at least the following methods:\n\n\nMyVector\nstring\n vec;\nvec.push_back(\nCS14\n);\nvec.push_back(\nWorld\n);\nvec.insert(\nHello\n, 0); \ncout \n vec.front() \n endl; // \nHello\n\ncout \n vec.back() \n endl; // \nWorld\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nCS14\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nHello\n\n\nMyVector\nint\n another_vec;\nanother_vec.push_back(42);\n\n\n\n\nStretch-goal exercise:\n\n\nRewrite your IntList as a class template!", 
            "title": "Lab Week 1"
        }, 
        {
            "location": "/lab_week_01/#lab-1-templates", 
            "text": "You may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".  In order to implement a Linked List, you must define the structure\nfor an individual node.   For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode * next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};  That's all fine and dandy, but if instead want a  DoubleList  or a StringList , then we are in trouble.   A common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to  make mistakes \ncopy and pasting.", 
            "title": "Lab 1: Templates"
        }, 
        {
            "location": "/lab_week_01/#introducing-templates", 
            "text": "The solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.  In fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.  To create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".  vector int  numbers; // creates a vector of integers\nvector string  words; // creates a vector of strings  To create a new class template, before our class declaration we use the keyword  template  followed by a type parameter inside \"angle-brackets\"\ne.g.  template typename T . The keyword  typename  tells the compiler\nthat  T  is a placeholder for an actual type.   Note:  T  is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is  Container  Let's say, we want to create a templated version of our Node and List.  IntNode  becomes:  template typename T \nstruct Node {\n   T val;\n   Node T  * next;\n};  and  IntLinkedList  becomes:  template typename T \nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node T  * head;\n};  To create a  LinkedList  of doubles, we declare the list as so:  LinkedList double  list;  In order to template functions and method, we do something similar.  For example, if we want to define the templated LinkedList's push_front  method:  template typename T \nLinkedList T ::push_front(T val) {\n    Node * new_node = new Node T ();\n    new_node -  val = val;\n\n    Node * old_head = this -  head;\n    new_node -  next = old_head;\n    this -  head = new_node;\n}  For more info on templates check out  this FAQ !", 
            "title": "Introducing templates!"
        }, 
        {
            "location": "/lab_week_01/#exercises", 
            "text": "Implement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!   Pro-Tip: before implementing the class as a class template,  typedef  the type  T  as an integer and replace type with  T  as needed. \ne.g.  typedef int T; // give the int an alias which is T\nT my_int = 42;  This give you much nicer error messages and makes it easier to debug.  Example Usage, should implement at least the following methods:  MyVector string  vec;\nvec.push_back( CS14 );\nvec.push_back( World );\nvec.insert( Hello , 0); \ncout   vec.front()   endl; //  Hello \ncout   vec.back()   endl; //  World \nvec.pop_back();\ncout   vec.back()   endl; //  CS14 \nvec.pop_back();\ncout   vec.back()   endl; //  Hello \n\nMyVector int  another_vec;\nanother_vec.push_back(42);", 
            "title": "Exercises"
        }, 
        {
            "location": "/lab_week_01/#stretch-goal-exercise", 
            "text": "Rewrite your IntList as a class template!", 
            "title": "Stretch-goal exercise:"
        }, 
        {
            "location": "/lec_week_02/", 
            "text": "Lecture 2: Lists, Queues, and Stacks\n\n\nQuestion of the day!\n\n\n\n\nHow many programmers does it take to change a light bulb?\n\n\n\n\n\n\n\n\nNone. That's a hardware problem.\n\n\n\n\n\n\n\n\n\n\nLists\n\n\nAn \nabstract data type (ADT)\n is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.\n\n\nLists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a \nnode\n.\n\n\nSingly-linked Lists\n\n\nSingly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the \nhead\n, and the last node is the \ntail\n.\n\n\n\n    The head in this case would be the node with value 12 and the tail would be the node with value 37\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node. \n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};\n\n\n\n\nDoubly Linked List\n\n\nIn a doubly linked list, each node contains three parts:\n\n\n\n\nData\n\n\nPointer to the next node\n\n\nPointer to the previous node\n\n\n\n\n\n\nIn this case, our new struct may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};\n\n\n\n\nStacks\n\n\nStacks are LIFO (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.\n\n\nHere's a small demo of how stacks work:\n\n\n#include \niostream\n\n#include \nstack\n\n\nusing namespace std;\n\nint main() {\n  stack\nint\n s;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout \n \nPopping (\n \n s.top() \n \n)\n \n endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout \n \nstack is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nTry running that and see what is output.\nGo ahead. I'll wait.\n\n\nWere you surprised by the output?\n\n\nQueues\n\n\n\n\nThe word queue is pronounced \"Q\" because all the other letters are waiting their turn...\n\n\n\n\nQueues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.\n\n\nHere's a small demo of how queues work:\n\n\n#include \niostream\n\n#include \nqueue\n\n\nusing namespace std;\n\nint main() {\n  queue\nint\n q;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout \n \nPopping (\n \n q.front() \n \n)\n \n endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout \n \nqueue is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nRun it!!", 
            "title": "Lecture Week 2"
        }, 
        {
            "location": "/lec_week_02/#lecture-2-lists-queues-and-stacks", 
            "text": "", 
            "title": "Lecture 2: Lists, Queues, and Stacks"
        }, 
        {
            "location": "/lec_week_02/#question-of-the-day", 
            "text": "How many programmers does it take to change a light bulb?     None. That's a hardware problem.", 
            "title": "Question of the day!"
        }, 
        {
            "location": "/lec_week_02/#lists", 
            "text": "An  abstract data type (ADT)  is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.  Lists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a  node .", 
            "title": "Lists"
        }, 
        {
            "location": "/lec_week_02/#singly-linked-lists", 
            "text": "Singly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the  head , and the last node is the  tail .  \n    The head in this case would be the node with value 12 and the tail would be the node with value 37  In order to implement a Linked List, you must define the structure\nfor an individual node.   For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};", 
            "title": "Singly-linked Lists"
        }, 
        {
            "location": "/lec_week_02/#doubly-linked-list", 
            "text": "In a doubly linked list, each node contains three parts:   Data  Pointer to the next node  Pointer to the previous node    In this case, our new struct may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};", 
            "title": "Doubly Linked List"
        }, 
        {
            "location": "/lec_week_02/#stacks", 
            "text": "Stacks are LIFO (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.  Here's a small demo of how stacks work:  #include  iostream \n#include  stack \n\nusing namespace std;\n\nint main() {\n  stack int  s;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout    Popping (    s.top()    )    endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout    stack is empty    endl;\n\n  return 0;\n}  Try running that and see what is output.\nGo ahead. I'll wait.  Were you surprised by the output?", 
            "title": "Stacks"
        }, 
        {
            "location": "/lec_week_02/#queues", 
            "text": "The word queue is pronounced \"Q\" because all the other letters are waiting their turn...   Queues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.  Here's a small demo of how queues work:  #include  iostream \n#include  queue \n\nusing namespace std;\n\nint main() {\n  queue int  q;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout    Popping (    q.front()    )    endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout    queue is empty    endl;\n\n  return 0;\n}  Run it!!", 
            "title": "Queues"
        }
    ]
}