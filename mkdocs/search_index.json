{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs14-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS14 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 14 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lec_week_02/", 
            "text": "Lecture 2: Lists\n\n\nQuestion of the day!\n\n\n\n\nHow many programmers does it take to change a light bulb?\n\n\n\n\n\n\n\n\nNone. That's a hardware problem.\n\n\n\n\n\n\n\n\n\n\nLists\n\n\nAn \nabstract data type (ADT)\n is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.\n\n\nLists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a \nnode\n.\n\n\nSingly-linked Lists\n\n\nSingly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the \nhead\n, and the last node is the \ntail\n.\n\n\n\n    The head in this case would be the node with value 12 and the tail would be the node with value 37\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node.\n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};\n\n\n\n\nDoubly Linked List\n\n\nIn a doubly linked list, each node contains three parts:\n\n\n\n\nData\n\n\nPointer to the next node\n\n\nPointer to the previous node\n\n\n\n\n\n\nIn this case, our new struct may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};\n\n\n\n\nDummy Nodes\n\n\nSometimes, to make edge cases easier to handle, dummy nodes are used at the end of lists. For example:\n\n\n\n\nIn this image the list is of size 1, however there are three nodes. This is because the\nfirst and the last nodes are \"Dummy Nodes.\" Dummy Nodes are there to make lists \neasier to use. For example, without dummy nodes, writting a function typically requires\naccounting for the special cases such as when the list is empty or size one.\nTake for example the following code for a push back and pop front for a singly-linked\nlist with only a head pointer.\n\n\nvoid IntList :: pushBack(int n){\n    if(head == 0){\n        head = new Node(n);\n        return;\n    }\n    Node* loop = 0;\n    for(loop = head; loop-\nnext != 0; loop = loop-\nnext){}\n    loop-\nnext = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head == 0){\n        return; // list is empty\n    }\n    else if(head-\nnext == 0){\n        delete head;\n        head = 0;\n    }\n    else{\n        Node* temp = head;\n        head = head-\nnext;\n        delete temp;\n    }\n}\n\n\n\n\nUsing Dummy nodes, we can reduce this code to the following:\n\n\nvoid IntList :: pushBack(int n){\n    Node* loop = 0;\n    for(loop = head; loop-\nnext != 0; loop = loop-\nnext){}\n    loop-\nnext = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head-\nnext == 0){\n        return; //list is empty\n    }\n    else{\n        Node* temp = head-\nnext;\n        head-\nnext = temp-\nnext;\n        delete temp;\n    }\n}\n\n\n\n\nNotice how in both functions, the \nif(head == 0)\n is no longer a case we have to check for\n(since head will never be 0). This helps simplify the code and handle common edge cases.\n\n\nOther functions must of course also be changed such as the print function, but the overall\ncomplexity of the code decreases. The contents of the dummy node don't matter as they shouldn't\never be seen.\n\n\nExercise 1: Fibonacci Exercise\n\n\nFn = Fn-1 + Fn-2\n\n\nF0 = 0, F1 = 1\n\n\nWrite a program that will calculate a specified fibonacci number using the \nstd::list data\n\nstructure. Think about how to use a list to store values of the formula above.\n\n\n\n\nInput:    integer n\n\n\nOutput:   nth Fibonacci number\n\n\n\n\nExample:\n\n\n\n\nWhich Fibonacci number to calculate: \n10\n\n\n10th Fibonacci number: \n55\n\n\n\n\nExercise 2: Palindrome Exercise\n\n\nWrite a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.\n\n\n\n\nInput:    string input\n\n\nOutput:   result of the palindrome test\n\n\n\n\nExample:\n\n\n\n\nEnter a word to test for palindrome: \ntacocats\n\n\ntacocats\n is not a palindrome.\n\n\n\n\nKey functions to incorporate: back(), pop_back()\n\n\nExercise 3: Animation!\n\n\nWe've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!\n\n\nAt the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into \ncout\n!\n\n\nNote, since we're giving you a precompiled file, you're going to have to use C9 for this exercise\n\n\nHow to get the code\n\n\nIn your C9 terminal, run the following in the directory where you want the code\n\n\ngit clone https://github.com/scohe001/Animations\n\n\n\nYou'll notice you now have a \nmain\n, an \nAnimator\n class and a couple animation files (don't look at them yet, it'll ruin the surprise!\n*\n).\n\n\nWe've already completely implemented the \nAnimator\n class for you and compiled it, so all you'll have to do is finish off the \nmain\n skeleton! The details for doing so are in the comments, so don't just delete them!\n\n\nCompiling\n\n\nSince we're using C++11 features and threading, you'll have to compile with the following:\n\n\ng++ -std=c++11 -pthread -Wall main.cpp animation.o\n\n\n\nAfter you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!\n\n\nOnce you have all of the animations working, delete \nanimation.o\n and use the skeleton \nanimation.cpp\n we've given you to complete the \nAnimation\n class! Recompiling the \nAnimation\n class should look like the following:\n\n\ng++ -std=c++11 -pthread -c animation.cpp\n\n\n\n*\n Since you're all CS majors I'm sure the lot of you have already looked at them \n.", 
            "title": "Lecture Week 2"
        }, 
        {
            "location": "/lec_week_02/#lecture-2-lists", 
            "text": "", 
            "title": "Lecture 2: Lists"
        }, 
        {
            "location": "/lec_week_02/#question-of-the-day", 
            "text": "How many programmers does it take to change a light bulb?     None. That's a hardware problem.", 
            "title": "Question of the day!"
        }, 
        {
            "location": "/lec_week_02/#lists", 
            "text": "An  abstract data type (ADT)  is a data type described by pre-defined user operations, such as \"insert data at rear,\" without indicating how each operation is implemented.  Lists are a common ADT for holding data, with operations like appending a data item, removing a data item, searching and printing. Each item in a list ADT is called a  node .", 
            "title": "Lists"
        }, 
        {
            "location": "/lec_week_02/#singly-linked-lists", 
            "text": "Singly-linked lists is a data structure for implementing a list ADT, where each node has a data and a pointer to the next node. The list structure typically has pointers to the list's first node and last node. The list's first node is called the  head , and the last node is the  tail .  \n    The head in this case would be the node with value 12 and the tail would be the node with value 37  In order to implement a Linked List, you must define the structure\nfor an individual node.  For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode* head;\n    IntNode* tail;\n};", 
            "title": "Singly-linked Lists"
        }, 
        {
            "location": "/lec_week_02/#doubly-linked-list", 
            "text": "In a doubly linked list, each node contains three parts:   Data  Pointer to the next node  Pointer to the previous node    In this case, our new struct may look something like:  struct IntNode{\n    int val;\n    IntNode* next;\n    IntNode* previous;\n};", 
            "title": "Doubly Linked List"
        }, 
        {
            "location": "/lec_week_02/#dummy-nodes", 
            "text": "Sometimes, to make edge cases easier to handle, dummy nodes are used at the end of lists. For example:   In this image the list is of size 1, however there are three nodes. This is because the\nfirst and the last nodes are \"Dummy Nodes.\" Dummy Nodes are there to make lists \neasier to use. For example, without dummy nodes, writting a function typically requires\naccounting for the special cases such as when the list is empty or size one.\nTake for example the following code for a push back and pop front for a singly-linked\nlist with only a head pointer.  void IntList :: pushBack(int n){\n    if(head == 0){\n        head = new Node(n);\n        return;\n    }\n    Node* loop = 0;\n    for(loop = head; loop- next != 0; loop = loop- next){}\n    loop- next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head == 0){\n        return; // list is empty\n    }\n    else if(head- next == 0){\n        delete head;\n        head = 0;\n    }\n    else{\n        Node* temp = head;\n        head = head- next;\n        delete temp;\n    }\n}  Using Dummy nodes, we can reduce this code to the following:  void IntList :: pushBack(int n){\n    Node* loop = 0;\n    for(loop = head; loop- next != 0; loop = loop- next){}\n    loop- next = new Node(n);\n}\n\nvoid IntList :: popFront(){\n    if(head- next == 0){\n        return; //list is empty\n    }\n    else{\n        Node* temp = head- next;\n        head- next = temp- next;\n        delete temp;\n    }\n}  Notice how in both functions, the  if(head == 0)  is no longer a case we have to check for\n(since head will never be 0). This helps simplify the code and handle common edge cases.  Other functions must of course also be changed such as the print function, but the overall\ncomplexity of the code decreases. The contents of the dummy node don't matter as they shouldn't\never be seen.", 
            "title": "Dummy Nodes"
        }, 
        {
            "location": "/lec_week_02/#exercise-1-fibonacci-exercise", 
            "text": "Fn = Fn-1 + Fn-2  F0 = 0, F1 = 1  Write a program that will calculate a specified fibonacci number using the  std::list data \nstructure. Think about how to use a list to store values of the formula above.   Input:    integer n  Output:   nth Fibonacci number   Example:   Which Fibonacci number to calculate:  10  10th Fibonacci number:  55", 
            "title": "Exercise 1: Fibonacci Exercise"
        }, 
        {
            "location": "/lec_week_02/#exercise-2-palindrome-exercise", 
            "text": "Write a program that will test to see if a specific word is a palindrome using the std::list\ndata structure.   Input:    string input  Output:   result of the palindrome test   Example:   Enter a word to test for palindrome:  tacocats  tacocats  is not a palindrome.   Key functions to incorporate: back(), pop_back()", 
            "title": "Exercise 2: Palindrome Exercise"
        }, 
        {
            "location": "/lec_week_02/#exercise-3-animation", 
            "text": "We've written the foundation for a program to create animations in the terminal, all you have to do is connect the dots!  At the moment, the program will push encrypted characters that need to be displayed into a queue, but those characters still need to be put into  cout !  Note, since we're giving you a precompiled file, you're going to have to use C9 for this exercise", 
            "title": "Exercise 3: Animation!"
        }, 
        {
            "location": "/lec_week_02/#how-to-get-the-code", 
            "text": "In your C9 terminal, run the following in the directory where you want the code  git clone https://github.com/scohe001/Animations  You'll notice you now have a  main , an  Animator  class and a couple animation files (don't look at them yet, it'll ruin the surprise! * ).  We've already completely implemented the  Animator  class for you and compiled it, so all you'll have to do is finish off the  main  skeleton! The details for doing so are in the comments, so don't just delete them!", 
            "title": "How to get the code"
        }, 
        {
            "location": "/lec_week_02/#compiling", 
            "text": "Since we're using C++11 features and threading, you'll have to compile with the following:  g++ -std=c++11 -pthread -Wall main.cpp animation.o  After you get your main up and running, test it out with all four animations! I'd highly suggest starting with the Eyes animation, as it's the simplest by far of all of them so it'll be easier to debug. Once you get one animation working, they should all work!  Once you have all of the animations working, delete  animation.o  and use the skeleton  animation.cpp  we've given you to complete the  Animation  class! Recompiling the  Animation  class should look like the following:  g++ -std=c++11 -pthread -c animation.cpp  *  Since you're all CS majors I'm sure the lot of you have already looked at them  .", 
            "title": "Compiling"
        }, 
        {
            "location": "/lab_week_02/", 
            "text": "Lab 2: The Standard Template Library\n\n\nThe Standard Template Library, or the \nSTL\n for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.\n\n\nSome of these algorithms range from simple algorithms such\nas \nstd::swap\n to the more complex \nstd::sort\n.\n\n\nThe motivation for learning and mastering the STL is to write \ncode that is clear and concise\n.\n\n\nIterators\n\n\nProbably the most important and inescapable concept in the\nSTL is the types we call iterators.\n\n\nIterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).\n\n\nThe easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).\n\n\n\"Enough talk, show me the code!\"\n Here's how you can iterate through a vector using iterators!\n\n\nvector\nint\n vec {1, 2, 3};\nvector\nint\n::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout \n *vec_iterator \n ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \n1 2 3 \n\n\n\n\n\nNote the \nvec.begin()\n and \nvec.end()\n calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type \nvector\nint\n::iterator\n.\n\n\nvec.begin()\n returns an iterator to beginning of \nvec\n. However, \nvec.end()\n returns an iterator to the element \none past\n the last element.\n\n\nThis is pictured below (image from en.cppreference.com)\n\n\n\nA lot of algorithms in the STL, including \nstd::sort\n\nexpect iterators as arguments. \n(and usually specific types of iterators)\n\n\nOne of the function prototypes for \nstd::sort\n looks\nsomething like this:\n\n\ntemplate\ntypename RandomIt\n\nvoid sort(Iterator first, Iterator last);\n\n\n\n\nAs long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).\n\n\n#include \niostream\n\n#include \nvector\n\n#include \nalgorithm\n\nusing namespace std;\nint main() {\n    vector\nint\n vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout \n *vec_iter \n ' ';\n    }\n}\n\n\n\n\n`\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nThat's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!\n\n\nFunction Objects\n\n\nBack in CS12, you learned that you can \noverload\n\nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the\n\n+\n operator may look like this (assume the \ngcd\n function is defined):\n\n\nbool operator+(const Rational \n other) {\n    int new_denom = gcd(this -\n denom, other.denom);\n    int this_multipler = new_denom/(this -\n denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -\n numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}\n\n\n\n\nYou can also overload the function call operator by\ndefining a function with the function name \noperator()\n.\n\n\ne.g.\n\n\n#include \niostream\n\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout \n count.get_count() \n endl;\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nOverloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include \nstd::sort\n\nand \nstd::copy_if\n. The most common types of\nfunction objects that these algorithms accept as input are\n\ncomparison function objects\n which return\ntrue if the first argument is \nconsidered\n less than the second and\na unary predicate which returns true if it satisfies some condition.\n\n\n#include \niostream\n\n#include \nalgorithm\n\n#include \nvector\n\n#include \nlist\n\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int \n a, const int \n b ) const {\n            return a \n b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int \n x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector\nint\n from_vector {1, 2, 3, 4};\n    list\nint\n to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout \n elem \n ' ';\n    }\n    cout \n endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout \n elem \n ' ';\n    }\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nExercise 1 - Reverse Polish Notation\n\n\nReverse Polish notation (RPN)\n is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.\n\n\nIn reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.\n\n\nAn advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".\n\n\nYour task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.\n\n\nExample:\n\n\n\n\nInput: 5 1 2 + 4 * + 3 -\n\n\nOutput: 14\n\n\n\n\nFor this exercise, implement the calculator using your choice of list.\n\n\nCool References\n\n\nStandard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Lab Week 2"
        }, 
        {
            "location": "/lab_week_02/#lab-2-the-standard-template-library", 
            "text": "The Standard Template Library, or the  STL  for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.  Some of these algorithms range from simple algorithms such\nas  std::swap  to the more complex  std::sort .  The motivation for learning and mastering the STL is to write  code that is clear and concise .", 
            "title": "Lab 2: The Standard Template Library"
        }, 
        {
            "location": "/lab_week_02/#iterators", 
            "text": "Probably the most important and inescapable concept in the\nSTL is the types we call iterators.  Iterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).  The easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).  \"Enough talk, show me the code!\"  Here's how you can iterate through a vector using iterators!  vector int  vec {1, 2, 3};\nvector int ::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout   *vec_iterator   ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs  1 2 3    Note the  vec.begin()  and  vec.end()  calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type  vector int ::iterator .  vec.begin()  returns an iterator to beginning of  vec . However,  vec.end()  returns an iterator to the element  one past  the last element.  This is pictured below (image from en.cppreference.com)  A lot of algorithms in the STL, including  std::sort \nexpect iterators as arguments.  (and usually specific types of iterators)  One of the function prototypes for  std::sort  looks\nsomething like this:  template typename RandomIt \nvoid sort(Iterator first, Iterator last);  As long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).  #include  iostream \n#include  vector \n#include  algorithm \nusing namespace std;\nint main() {\n    vector int  vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout   *vec_iter   ' ';\n    }\n}  ` Try it yourself - before compiling guess what the above program outputs.  That's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!", 
            "title": "Iterators"
        }, 
        {
            "location": "/lab_week_02/#function-objects", 
            "text": "Back in CS12, you learned that you can  overload \nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the +  operator may look like this (assume the  gcd  function is defined):  bool operator+(const Rational   other) {\n    int new_denom = gcd(this -  denom, other.denom);\n    int this_multipler = new_denom/(this -  denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -  numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}  You can also overload the function call operator by\ndefining a function with the function name  operator() .  e.g.  #include  iostream \nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout   count.get_count()   endl;\n}  Try it yourself - before compiling guess what the above program outputs.  Overloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include  std::sort \nand  std::copy_if . The most common types of\nfunction objects that these algorithms accept as input are comparison function objects  which return\ntrue if the first argument is  considered  less than the second and\na unary predicate which returns true if it satisfies some condition.  #include  iostream \n#include  algorithm \n#include  vector \n#include  list \nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int   a, const int   b ) const {\n            return a   b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int   x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector int  from_vector {1, 2, 3, 4};\n    list int  to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout   elem   ' ';\n    }\n    cout   endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout   elem   ' ';\n    }\n}  Try it yourself - before compiling guess what the above program outputs.", 
            "title": "Function Objects"
        }, 
        {
            "location": "/lab_week_02/#exercise-1-reverse-polish-notation", 
            "text": "Reverse Polish notation (RPN)  is a mathematical notation in which every operator follows all of its operands. It is also known as postfix notation and does not need any parentheses as long as each operator has a fixed number of operands.  In reverse Polish notation the operators follow their operands; for instance, to add 3 and 4, one would write \"3 4 +\" rather than \"3 + 4\". If there are multiple operations, the operator is given immediately after its second operand; so the expression written \"3 \u2212 4 + 5\" in conventional notation would be written \"3 4 \u2212 5 +\" in RPN: 4 is first subtracted from 3, then 5 added to it.  An advantage of RPN is that it removes the need for parentheses that are required by infix. While \"3 \u2212 4 * 5\" can also be written \"3 \u2212 (4 * 5)\", that means something quite different from \"(3 \u2212 4) * 5\". In postfix, the former could be written \"3 4 5 * \u2212\", which unambiguously means \"3 (4 5 * ) \u2212\" which reduces to \"3 20 \u2212\"; the latter could be written \"3 4 \u2212 5 * \" (or 5 3 4 \u2212 * , if keeping similar formatting), which unambiguously means \"(3 4 \u2212) 5 * \".  Your task is to implement a reverse polish notation calculator that reads in an equation and calculates the result.  Example:   Input: 5 1 2 + 4 * + 3 -  Output: 14   For this exercise, implement the calculator using your choice of list.", 
            "title": "Exercise 1 - Reverse Polish Notation"
        }, 
        {
            "location": "/lab_week_02/#cool-references", 
            "text": "Standard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Cool References"
        }, 
        {
            "location": "/lec_week_03/", 
            "text": "Big-O Time Complexity\n\n\nFor the following functions give the nearest Big-O time complexity.\n\n\nProblem 1\n\n\nint f1(const std::vector\nint\n v) {\n    int result = 0;\n    for (int i = 0; i \n v.size(); ++i) {\n        for (int j = v.size(); j \n= 0; j -= 2) {\n            result += v.at(i) * j;\n        }\n    }\n    return result;\n}\n\n\n\n\nProblem 2\n\n\nvoid f2(std::list\nint\n l, int n) {\n    for (int i = 0; i \n n; ++i) {\n        l.remove(i);\n    }\n}\n\n\n\n\nProblem 3\n\n\nvoid f3(int n, int m, int r) {\n    for (int i = 0; i \n n; ++i) {\n        for (int j = m; m \n 0; m /= 2) {\n            while (r \n 0) {\n                std::cout \n r \n std::endl;\n                --r;\n            }\n        }\n    }\n}\n\n\n\n\nProblem 4\n\n\nvoid f4(std::vector\nint\n v) {\n    for (std::vector\nint\n::iterator itr = v.begin(); itr != v.end(); ++itr) {\n        std::random_shuffle(itr, v.end());\n        for (auto itr2 = v.begin(); itr2 != v.end(); ++itr2) {\n            std::cout \n *itr2 \n ' ';\n        }\n        std::cout \n std::endl;\n    }\n    std::sort(v.begin(), v.end());\n}\n\n\n\n\nProblem 5\n\n\nvoid f5(std::stack\nint\n s) {\n    if (s.empty()) return;\n    std::stack\nint\n temp;\n    int min;\n    for (int i = 0; i \n s.size(); ++i) {\n        min = s.top();\n        s.pop();\n        for(int j = i; j \n s.size(); ++j) {\n            if (s.top() \n min) {\n                temp.push(min);\n                min = s.top();\n            }\n            else temp.push(s.top());\n            s.pop();\n        }i\n        s.push(min);\n        while(!temp.empty()) {\n            s.push(temp.top());\n            temp.pop();\n        }\n    }\n}\n\n\n\n\nProblem 6\n\n\nFor this problem just give the Big-O time complexity for \nf6\n\n\nBonus: What is the Big-O space complexity for \nf6\n?\n\n\n\n\nvoid f6(std::queue\nint\n q) {\n    if (q.size() \n= 1) return;\n    std::queue\nint\n left;\n    std::queue\nint\n right;\n    for (int i = 0; i \n q.size() / 2; ++i) {\n        left.push(q.front());\n        q.pop();\n    }\n    while(!q.empty()) {\n        right.push(q.front());\n        q.pop();\n    }\n    f6(left);\n    f6(right);\n    q = f7(left, right);\n}\n\nstd::queue\nint\n f7(std::queue\nint\n left, std::queue\nint\n right){\n    std::queue\nint\n result;\n    while(!left.empty() \n !right.empty()) {\n        if (left.front() \n right.front()) {\n            resulti.push(right.front());\n            right.pop();\n        }\n        else {\n            result.push(left.front());\n            left.pop();\n        }\n    }\n    while(!left.empty()) {\n        result.push(left.front());\n        left.pop();\n    }\n    while(!right.empty()) {\n        result.push(right.front());\n        right.pop();\n    }\n    return result;\n}", 
            "title": "Big-O Analysis"
        }, 
        {
            "location": "/lec_week_03/#big-o-time-complexity", 
            "text": "For the following functions give the nearest Big-O time complexity.", 
            "title": "Big-O Time Complexity"
        }, 
        {
            "location": "/lec_week_03/#problem-1", 
            "text": "int f1(const std::vector int  v) {\n    int result = 0;\n    for (int i = 0; i   v.size(); ++i) {\n        for (int j = v.size(); j  = 0; j -= 2) {\n            result += v.at(i) * j;\n        }\n    }\n    return result;\n}", 
            "title": "Problem 1"
        }, 
        {
            "location": "/lec_week_03/#problem-2", 
            "text": "void f2(std::list int  l, int n) {\n    for (int i = 0; i   n; ++i) {\n        l.remove(i);\n    }\n}", 
            "title": "Problem 2"
        }, 
        {
            "location": "/lec_week_03/#problem-3", 
            "text": "void f3(int n, int m, int r) {\n    for (int i = 0; i   n; ++i) {\n        for (int j = m; m   0; m /= 2) {\n            while (r   0) {\n                std::cout   r   std::endl;\n                --r;\n            }\n        }\n    }\n}", 
            "title": "Problem 3"
        }, 
        {
            "location": "/lec_week_03/#problem-4", 
            "text": "void f4(std::vector int  v) {\n    for (std::vector int ::iterator itr = v.begin(); itr != v.end(); ++itr) {\n        std::random_shuffle(itr, v.end());\n        for (auto itr2 = v.begin(); itr2 != v.end(); ++itr2) {\n            std::cout   *itr2   ' ';\n        }\n        std::cout   std::endl;\n    }\n    std::sort(v.begin(), v.end());\n}", 
            "title": "Problem 4"
        }, 
        {
            "location": "/lec_week_03/#problem-5", 
            "text": "void f5(std::stack int  s) {\n    if (s.empty()) return;\n    std::stack int  temp;\n    int min;\n    for (int i = 0; i   s.size(); ++i) {\n        min = s.top();\n        s.pop();\n        for(int j = i; j   s.size(); ++j) {\n            if (s.top()   min) {\n                temp.push(min);\n                min = s.top();\n            }\n            else temp.push(s.top());\n            s.pop();\n        }i\n        s.push(min);\n        while(!temp.empty()) {\n            s.push(temp.top());\n            temp.pop();\n        }\n    }\n}", 
            "title": "Problem 5"
        }, 
        {
            "location": "/lec_week_03/#problem-6", 
            "text": "For this problem just give the Big-O time complexity for  f6  Bonus: What is the Big-O space complexity for  f6 ?  \n\nvoid f6(std::queue int  q) {\n    if (q.size()  = 1) return;\n    std::queue int  left;\n    std::queue int  right;\n    for (int i = 0; i   q.size() / 2; ++i) {\n        left.push(q.front());\n        q.pop();\n    }\n    while(!q.empty()) {\n        right.push(q.front());\n        q.pop();\n    }\n    f6(left);\n    f6(right);\n    q = f7(left, right);\n}\n\nstd::queue int  f7(std::queue int  left, std::queue int  right){\n    std::queue int  result;\n    while(!left.empty()   !right.empty()) {\n        if (left.front()   right.front()) {\n            resulti.push(right.front());\n            right.pop();\n        }\n        else {\n            result.push(left.front());\n            left.pop();\n        }\n    }\n    while(!left.empty()) {\n        result.push(left.front());\n        left.pop();\n    }\n    while(!right.empty()) {\n        result.push(right.front());\n        right.pop();\n    }\n    return result;\n}", 
            "title": "Problem 6"
        }
    ]
}