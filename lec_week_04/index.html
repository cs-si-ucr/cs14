<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Lecture Week 4 - CS14 SI: Spring 2015</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Lecture Week 4";
    var mkdocs_page_input_path = "lec_week_04.md";
    var mkdocs_page_url = "/lec_week_04/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> CS14 SI: Spring 2015</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lec_week_02/">Lecture Week 2</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lab_week_02/">Lab Week 2</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Lecture Week 3</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../lec_week_03/">Stacks & Queues</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../lec_week_03_pt2/">Exceptions</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../lec_week_03_pt3/">Templates</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lab_week_03/">Lab Week 3</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Lecture Week 4</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#binary-search-trees-bst">Binary Search Trees (BST)</a></li>
                
                    <li><a class="toctree-l4" href="#whats-a-tree">What's a tree?</a></li>
                
                    <li><a class="toctree-l4" href="#whats-a-bst">What's a BST?</a></li>
                
                    <li><a class="toctree-l4" href="#bst-searching-algorithm">BST Searching algorithm</a></li>
                
                    <li><a class="toctree-l4" href="#bst-insert-algorithm">BST Insert Algorithm</a></li>
                
                    <li><a class="toctree-l4" href="#bst-delete-algorithm">BST Delete Algorithm</a></li>
                
                    <li><a class="toctree-l4" href="#put-it-into-practice">Put it into practice!</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lab_week_04/">Lab Week 4</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lec_week_05/">Lecture Week 5</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lab_week_06/">Lab Week 6</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">CS14 SI: Spring 2015</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Lecture Week 4</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="binary-search-trees-bst">Binary Search Trees (BST)</h1>
<iframe src="//giphy.com/embed/5mBE2MiMVFITS" width="480" height="319" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

<p><a href="http://giphy.com/gifs/paul-comment-ron-5mBE2MiMVFITS"></a></p>

<h2 id="whats-a-tree">What's a tree?</h2>
<p>Trees are often easier to deal with recursively (or if you're a mathematician, 'inductively').
Thus, to define a tree recursively, we can say that:</p>
<ol>
<li>A Tree is a system of <strong>nodes</strong><ul>
<li>A node consists of a value and pointers to its children</li>
<li>An <strong>Internal Node</strong> is a node with at least one child</li>
</ul>
</li>
<li>Every node has a unique <strong>parent</strong><ul>
<li>A node with a child is said to be that child's parent</li>
<li>A node's <strong>ancestor</strong> include the node's parent, the parent's parent, ect., up to the tree's root</li>
<li>No node has more than one parent</li>
</ul>
</li>
<li>The <strong>Root</strong> of a tree has no parent</li>
<li>A Node can have any number of children (including 0)</li>
</ol>
<p>When we put all of these things together, we end up with something looking like:</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/220px-Binary_tree.svg.png" alt="It's a Tree!" style="width: 250px;"/></p>
<p>Where the numbers in the nodes represent the value at that node, and the arrows represent pointers to children nodes.</p>
<p>Here are a few additional terms that are good to know about trees:</p>
<ul>
<li>The link from a node to a child is called an <strong>edge</strong>.</li>
<li>A node's <strong>depth</strong> is the number of edges on the path from the root to the node. The root node thus has depth 0.</li>
<li>All nodes with the same depth form a tree <strong>level</strong>.</li>
<li>A tree's <strong>height</strong> is the largest depth of any node. A tree with just one node has height 0.</li>
</ul>
<h2 id="whats-a-bst">What's a BST?</h2>
<p>A Binary Search Tree is exactly like any other tree, except every node has <strong>exactly</strong> two children (if there is no child, the node will be a null pointer).
Furtermore (and more importantly), every child to the left of a node will be less than the node, while every child to the right will be greater.</p>
<p>You'll notice that the picture above is <strong>NOT</strong> a BST. Even though each node has two children (we can pretend that there are invisible null children), if we go to the left child of our root, we find a value that is <em>greater</em>, breaking our definition.</p>
<p><strong>This</strong> would be a valid Binary Search Tree:</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/2000px-Binary_search_tree.svg.png" alt="It's a BST!" style="width: 250px;"/></p>
<p>Notice how <strong>every</strong> number to the left of any node (take 8 for example), is less than the node itself (1, 3, 4, 5, 7). Since this is the case, where will the smallest node be? What about the largest?</p>
<h2 id="bst-searching-algorithm">BST Searching algorithm</h2>
<p>Given a key, a search algorithm returns the first node found matching that key, or returns 0 if a matching node is not found. A simple BST search algorithm checks the current node (initially the tree's root), returning that node as a match, else assigning the current node with the left (if key is less) or right (if key is greater) child and repeating. If such a child is 0, the algorithm returns 0 (matching node not found).</p>
<p>Here's an example of how powerful a BST can be. If we have a BST and a sorted array, searching for a specific number can be much faster.</p>
<p><img src="https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif"/></p>
<h2 id="bst-insert-algorithm">BST Insert Algorithm</h2>
<p>Given a new node, a BST insert operation inserts the new node in a proper location obeying the BST ordering property. A simple BST insert algorithm compares the new node with the current node (initially the root):</p>
<ul>
<li><strong>Insert as left child:</strong> If the new node's key is less than the current node, and the current node's left child is 0, the algorithm assigns that node's left child with the new node.</li>
<li><strong>Insert as right child:</strong> If the new node's key is greater than the current node, and the current node's right child is 0, the algorithm assigns the node's right child with the new node.</li>
<li><strong>Search for insert location:</strong> If the left (or right) child is not 0, the algorithm assigns the current node with that child and continues searching for a proper insert location.</li>
</ul>
<p>Here's an animated example of BST insertion:</p>
<p><img src="https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-insertion-animation.gif"/></p>
<h2 id="bst-delete-algorithm">BST Delete Algorithm</h2>
<p>Deletion in a BST is a bit tedious as compared to Insertion and searching. This is because the resultant tree after deleting a node from a BST must also be a BST (it should preserve the BST property).</p>
<p>Given a key, a BST remove operation removes the first-found matching node, restructuring the tree to preserve the BST ordering property. The algorithm first searches for a matching node just like the search algorithm. If found (call this node X), the algorithm performs one of the following sub-algorithms:</p>
<ul>
<li><strong>Remove a leaf node:</strong> If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with 0. Else, if X was the root, the root pointer is assigned with 0, and the BST is now empty.
<img src="http://www.mybodhizone.com/data_structures/images/BST_delete_no_child.gif"/></li>
<li><strong>Remove an internal node with single child:</strong> If X has a parent (so X is not the root), the parent's left or right child (whichever points to X) is assigned with X's single child. Else, if X was the root, the root pointer is assigned with X's single child.
<img src="http://www.mybodhizone.com/data_structures/images/BST_delete_one_child.gif"/></li>
<li><strong>Remove an internal node with two children:</strong> This case is the hardest. First, the algorithm locates X's successor (the leftmost child of X's right subtree), and copies the successor to X. Then, the algorithm recursively removes the successor from the right subtree.
<img src="http://www.mybodhizone.com/data_structures/images/BST_delete_two_child.gif"/></li>
</ul>
<h2 id="put-it-into-practice">Put it into practice!</h2>
<p>We have created a <a href="https://gist.github.com/scohe001/65ae445a6577cb85b22c">simple implementation of a BST</a> for you to use. The class comes with the member functions <code>void push(T val)</code> to add values to the tree, and <code>void print()</code> to print a rough representation of the tree.</p>
<h6 id="note">NOTE:</h6>
<p><em>It is often almost always easier to write Tree functions recursively (as you'll see the push function has been written). However, it <strong>is</strong> possible to do all of the following exercises without recursion--you'll just need to be iterating over a stack you're constantly pushing and popping to (as you'll see the print function is doing).</em></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../lab_week_04/" class="btn btn-neutral float-right" title="Lab Week 4">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../lab_week_03/" class="btn btn-neutral" title="Lab Week 3"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../lab_week_03/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../lab_week_04/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
